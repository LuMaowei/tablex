{"remainingRequest":"/home/nexx/develop/tablex/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/nexx/develop/tablex/node_modules/docz-core/node_modules/babel-loader/lib/index.js??ref--5-2!/home/nexx/develop/tablex/node_modules/source-map-loader/index.js!/home/nexx/develop/tablex/src/tree-data-utils.js","dependencies":[{"path":"/home/nexx/develop/tablex/src/tree-data-utils.js","mtime":1555823102531},{"path":"/home/nexx/develop/tablex/node_modules/cache-loader/dist/cjs.js","mtime":1555737869369},{"path":"/home/nexx/develop/tablex/node_modules/thread-loader/dist/cjs.js","mtime":1555737872026},{"path":"/home/nexx/develop/tablex/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1555737864633},{"path":"/home/nexx/develop/tablex/node_modules/source-map-loader/index.js","mtime":1555737871137}],"contextDependencies":[],"result":["import _objectSpread from\"/home/nexx/develop/tablex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";import _toConsumableArray from\"/home/nexx/develop/tablex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";/**\n * Performs a depth-first traversal over all of the node descendants,\n * incrementing currentIndex by 1 for each\n */function getNodeDataAtTreeIndexOrNextIndex(_ref){var targetIndex=_ref.targetIndex,node=_ref.node,currentIndex=_ref.currentIndex,getNodeKey=_ref.getNodeKey,_ref$path=_ref.path,path=_ref$path===void 0?[]:_ref$path,_ref$lowerSiblingCoun=_ref.lowerSiblingCounts,lowerSiblingCounts=_ref$lowerSiblingCoun===void 0?[]:_ref$lowerSiblingCoun,_ref$ignoreCollapsed=_ref.ignoreCollapsed,ignoreCollapsed=_ref$ignoreCollapsed===void 0?true:_ref$ignoreCollapsed,_ref$isPseudoRoot=_ref.isPseudoRoot,isPseudoRoot=_ref$isPseudoRoot===void 0?false:_ref$isPseudoRoot;// The pseudo-root is not considered in the path\nvar selfPath=!isPseudoRoot?[].concat(_toConsumableArray(path),[getNodeKey({node:node,treeIndex:currentIndex})]):[];// Return target node when found\nif(currentIndex===targetIndex){return{node:node,lowerSiblingCounts:lowerSiblingCounts,path:selfPath};}// Add one and continue for nodes with no children or hidden children\nif(!node.children||ignoreCollapsed&&node.expanded!==true){return{nextIndex:currentIndex+1};}// Iterate over each child and their descendants and return the\n// target node if childIndex reaches the targetIndex\nvar childIndex=currentIndex+1;var childCount=node.children.length;for(var i=0;i<childCount;i+=1){var result=getNodeDataAtTreeIndexOrNextIndex({ignoreCollapsed:ignoreCollapsed,getNodeKey:getNodeKey,targetIndex:targetIndex,node:node.children[i],currentIndex:childIndex,lowerSiblingCounts:[].concat(_toConsumableArray(lowerSiblingCounts),[childCount-i-1]),path:selfPath});if(result.node){return result;}childIndex=result.nextIndex;}// If the target node is not found, return the farthest traversed index\nreturn{nextIndex:childIndex};}export function getDescendantCount(_ref2){var node=_ref2.node,_ref2$ignoreCollapsed=_ref2.ignoreCollapsed,ignoreCollapsed=_ref2$ignoreCollapsed===void 0?true:_ref2$ignoreCollapsed;return getNodeDataAtTreeIndexOrNextIndex({getNodeKey:function getNodeKey(){},ignoreCollapsed:ignoreCollapsed,node:node,currentIndex:0,targetIndex:-1}).nextIndex-1;}/**\n * Walk all descendants of the given node, depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */if(typeof getDescendantCount!=='undefined'&&getDescendantCount&&getDescendantCount===Object(getDescendantCount)&&Object.isExtensible(getDescendantCount)){Object.defineProperty(getDescendantCount,'__filemeta',{enumerable:true,configurable:true,value:{name:\"getDescendantCount\",filename:\"src/tree-data-utils.js\"}});}function walkDescendants(_ref3){var callback=_ref3.callback,getNodeKey=_ref3.getNodeKey,ignoreCollapsed=_ref3.ignoreCollapsed,_ref3$isPseudoRoot=_ref3.isPseudoRoot,isPseudoRoot=_ref3$isPseudoRoot===void 0?false:_ref3$isPseudoRoot,node=_ref3.node,_ref3$parentNode=_ref3.parentNode,parentNode=_ref3$parentNode===void 0?null:_ref3$parentNode,currentIndex=_ref3.currentIndex,_ref3$path=_ref3.path,path=_ref3$path===void 0?[]:_ref3$path,_ref3$lowerSiblingCou=_ref3.lowerSiblingCounts,lowerSiblingCounts=_ref3$lowerSiblingCou===void 0?[]:_ref3$lowerSiblingCou;// The pseudo-root is not considered in the path\nvar selfPath=isPseudoRoot?[]:[].concat(_toConsumableArray(path),[getNodeKey({node:node,treeIndex:currentIndex})]);var selfInfo=isPseudoRoot?null:{node:node,parentNode:parentNode,path:selfPath,lowerSiblingCounts:lowerSiblingCounts,treeIndex:currentIndex};if(!isPseudoRoot){var callbackResult=callback(selfInfo);// Cut walk short if the callback returned false\nif(callbackResult===false){return false;}}// Return self on nodes with no children or hidden children\nif(!node.children||node.expanded!==true&&ignoreCollapsed&&!isPseudoRoot){return currentIndex;}// Get all descendants\nvar childIndex=currentIndex;var childCount=node.children.length;if(typeof node.children!==\"function\"){for(var i=0;i<childCount;i+=1){childIndex=walkDescendants({callback:callback,getNodeKey:getNodeKey,ignoreCollapsed:ignoreCollapsed,node:node.children[i],parentNode:isPseudoRoot?null:node,currentIndex:childIndex+1,lowerSiblingCounts:[].concat(_toConsumableArray(lowerSiblingCounts),[childCount-i-1]),path:selfPath});// Cut walk short if the callback returned false\nif(childIndex===false){return false;}}}return childIndex;}/**\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */function mapDescendants(_ref4){var callback=_ref4.callback,getNodeKey=_ref4.getNodeKey,ignoreCollapsed=_ref4.ignoreCollapsed,_ref4$isPseudoRoot=_ref4.isPseudoRoot,isPseudoRoot=_ref4$isPseudoRoot===void 0?false:_ref4$isPseudoRoot,node=_ref4.node,_ref4$parentNode=_ref4.parentNode,parentNode=_ref4$parentNode===void 0?null:_ref4$parentNode,currentIndex=_ref4.currentIndex,_ref4$path=_ref4.path,path=_ref4$path===void 0?[]:_ref4$path,_ref4$lowerSiblingCou=_ref4.lowerSiblingCounts,lowerSiblingCounts=_ref4$lowerSiblingCou===void 0?[]:_ref4$lowerSiblingCou;var nextNode=_objectSpread({},node);// The pseudo-root is not considered in the path\nvar selfPath=isPseudoRoot?[]:[].concat(_toConsumableArray(path),[getNodeKey({node:nextNode,treeIndex:currentIndex})]);var selfInfo={node:nextNode,parentNode:parentNode,path:selfPath,lowerSiblingCounts:lowerSiblingCounts,treeIndex:currentIndex};// Return self on nodes with no children or hidden children\nif(!nextNode.children||nextNode.expanded!==true&&ignoreCollapsed&&!isPseudoRoot){return{treeIndex:currentIndex,node:callback(selfInfo)};}// Get all descendants\nvar childIndex=currentIndex;var childCount=nextNode.children.length;if(typeof nextNode.children!==\"function\"){nextNode.children=nextNode.children.map(function(child,i){var mapResult=mapDescendants({callback:callback,getNodeKey:getNodeKey,ignoreCollapsed:ignoreCollapsed,node:child,parentNode:isPseudoRoot?null:nextNode,currentIndex:childIndex+1,lowerSiblingCounts:[].concat(_toConsumableArray(lowerSiblingCounts),[childCount-i-1]),path:selfPath});childIndex=mapResult.treeIndex;return mapResult.node;});}return{node:callback(selfInfo),treeIndex:childIndex};}/**\n * Count all the visible (expanded) descendants in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n *\n * @return {number} count\n */export function getVisibleNodeCount(_ref5){var treeData=_ref5.treeData;var traverse=function traverse(node){if(!node.children||node.expanded!==true||typeof node.children===\"function\"){return 1;}return 1+node.children.reduce(function(total,currentNode){return total+traverse(currentNode);},0);};return treeData.reduce(function(total,currentNode){return total+traverse(currentNode);},0);}/**\n * Get the <targetIndex>th visible node in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} targetIndex - The index of the node to search for\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }|null} node - The node at targetIndex, or null if not found\n */if(typeof getVisibleNodeCount!=='undefined'&&getVisibleNodeCount&&getVisibleNodeCount===Object(getVisibleNodeCount)&&Object.isExtensible(getVisibleNodeCount)){Object.defineProperty(getVisibleNodeCount,'__filemeta',{enumerable:true,configurable:true,value:{name:\"getVisibleNodeCount\",filename:\"src/tree-data-utils.js\"}});}export function getVisibleNodeInfoAtIndex(_ref6){var treeData=_ref6.treeData,targetIndex=_ref6.index,getNodeKey=_ref6.getNodeKey;if(!treeData||treeData.length<1){return null;}// Call the tree traversal with a pseudo-root node\nvar result=getNodeDataAtTreeIndexOrNextIndex({targetIndex:targetIndex,getNodeKey:getNodeKey,node:{children:treeData,expanded:true},currentIndex:-1,path:[],lowerSiblingCounts:[],isPseudoRoot:true});if(result.node){return result;}return null;}/**\n * Walk descendants depth-first and call a callback on each\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return void\n */if(typeof getVisibleNodeInfoAtIndex!=='undefined'&&getVisibleNodeInfoAtIndex&&getVisibleNodeInfoAtIndex===Object(getVisibleNodeInfoAtIndex)&&Object.isExtensible(getVisibleNodeInfoAtIndex)){Object.defineProperty(getVisibleNodeInfoAtIndex,'__filemeta',{enumerable:true,configurable:true,value:{name:\"getVisibleNodeInfoAtIndex\",filename:\"src/tree-data-utils.js\"}});}export function walk(_ref7){var treeData=_ref7.treeData,getNodeKey=_ref7.getNodeKey,callback=_ref7.callback,_ref7$ignoreCollapsed=_ref7.ignoreCollapsed,ignoreCollapsed=_ref7$ignoreCollapsed===void 0?true:_ref7$ignoreCollapsed;if(!treeData||treeData.length<1){return;}walkDescendants({callback:callback,getNodeKey:getNodeKey,ignoreCollapsed:ignoreCollapsed,isPseudoRoot:true,node:{children:treeData},currentIndex:-1,path:[],lowerSiblingCounts:[]});}/**\n * Perform a depth-first transversal of the descendants and\n *  make a change to every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */if(typeof walk!=='undefined'&&walk&&walk===Object(walk)&&Object.isExtensible(walk)){Object.defineProperty(walk,'__filemeta',{enumerable:true,configurable:true,value:{name:\"walk\",filename:\"src/tree-data-utils.js\"}});}export function map(_ref8){var treeData=_ref8.treeData,getNodeKey=_ref8.getNodeKey,callback=_ref8.callback,_ref8$ignoreCollapsed=_ref8.ignoreCollapsed,ignoreCollapsed=_ref8$ignoreCollapsed===void 0?true:_ref8$ignoreCollapsed;if(!treeData||treeData.length<1){return[];}return mapDescendants({callback:callback,getNodeKey:getNodeKey,ignoreCollapsed:ignoreCollapsed,isPseudoRoot:true,node:{children:treeData},currentIndex:-1,path:[],lowerSiblingCounts:[]}).node.children;}/**\n * Expand or close every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {?boolean} expanded - Whether the node is expanded or not\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */if(typeof map!=='undefined'&&map&&map===Object(map)&&Object.isExtensible(map)){Object.defineProperty(map,'__filemeta',{enumerable:true,configurable:true,value:{name:\"map\",filename:\"src/tree-data-utils.js\"}});}export function toggleExpandedForAll(_ref9){var treeData=_ref9.treeData,_ref9$expanded=_ref9.expanded,expanded=_ref9$expanded===void 0?true:_ref9$expanded;return map({treeData:treeData,callback:function callback(_ref10){var node=_ref10.node;return _objectSpread({},node,{expanded:expanded});},getNodeKey:function getNodeKey(_ref11){var treeIndex=_ref11.treeIndex;return treeIndex;},ignoreCollapsed:false});}/**\n * Replaces node at path with object, or callback-defined object\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */if(typeof toggleExpandedForAll!=='undefined'&&toggleExpandedForAll&&toggleExpandedForAll===Object(toggleExpandedForAll)&&Object.isExtensible(toggleExpandedForAll)){Object.defineProperty(toggleExpandedForAll,'__filemeta',{enumerable:true,configurable:true,value:{name:\"toggleExpandedForAll\",filename:\"src/tree-data-utils.js\"}});}export function changeNodeAtPath(_ref12){var treeData=_ref12.treeData,path=_ref12.path,newNode=_ref12.newNode,getNodeKey=_ref12.getNodeKey,_ref12$ignoreCollapse=_ref12.ignoreCollapsed,ignoreCollapsed=_ref12$ignoreCollapse===void 0?true:_ref12$ignoreCollapse;var RESULT_MISS=\"RESULT_MISS\";var traverse=function traverse(_ref13){var _ref13$isPseudoRoot=_ref13.isPseudoRoot,isPseudoRoot=_ref13$isPseudoRoot===void 0?false:_ref13$isPseudoRoot,node=_ref13.node,currentTreeIndex=_ref13.currentTreeIndex,pathIndex=_ref13.pathIndex;if(!isPseudoRoot&&getNodeKey({node:node,treeIndex:currentTreeIndex})!==path[pathIndex]){return RESULT_MISS;}if(pathIndex>=path.length-1){// If this is the final location in the path, return its changed form\nreturn typeof newNode===\"function\"?newNode({node:node,treeIndex:currentTreeIndex}):newNode;}if(!node.children){// If this node is part of the path, but has no children, return the unchanged node\nthrow new Error(\"Path referenced children of node with no children.\");}var nextTreeIndex=currentTreeIndex+1;for(var i=0;i<node.children.length;i+=1){var _result=traverse({node:node.children[i],currentTreeIndex:nextTreeIndex,pathIndex:pathIndex+1});// If the result went down the correct path\nif(_result!==RESULT_MISS){if(_result){// If the result was truthy (in this case, an object),\n//  pass it to the next level of recursion up\nreturn _objectSpread({},node,{children:[].concat(_toConsumableArray(node.children.slice(0,i)),[_result],_toConsumableArray(node.children.slice(i+1)))});}// If the result was falsy (returned from the newNode function), then\n//  delete the node from the array.\nreturn _objectSpread({},node,{children:[].concat(_toConsumableArray(node.children.slice(0,i)),_toConsumableArray(node.children.slice(i+1)))});}nextTreeIndex+=1+getDescendantCount({node:node.children[i],ignoreCollapsed:ignoreCollapsed});}return RESULT_MISS;};// Use a pseudo-root node in the beginning traversal\nvar result=traverse({node:{children:treeData},currentTreeIndex:-1,pathIndex:-1,isPseudoRoot:true});if(result===RESULT_MISS){throw new Error(\"No node found at the given path.\");}return result.children;}/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The tree data with the node removed\n */if(typeof changeNodeAtPath!=='undefined'&&changeNodeAtPath&&changeNodeAtPath===Object(changeNodeAtPath)&&Object.isExtensible(changeNodeAtPath)){Object.defineProperty(changeNodeAtPath,'__filemeta',{enumerable:true,configurable:true,value:{name:\"changeNodeAtPath\",filename:\"src/tree-data-utils.js\"}});}export function removeNodeAtPath(_ref14){var treeData=_ref14.treeData,path=_ref14.path,getNodeKey=_ref14.getNodeKey,_ref14$ignoreCollapse=_ref14.ignoreCollapsed,ignoreCollapsed=_ref14$ignoreCollapse===void 0?true:_ref14$ignoreCollapse;return changeNodeAtPath({treeData:treeData,path:path,getNodeKey:getNodeKey,ignoreCollapsed:ignoreCollapsed,newNode:null// Delete the node\n});}/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node removed\n * @return {Object} result.node - The node that was removed\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\n */if(typeof removeNodeAtPath!=='undefined'&&removeNodeAtPath&&removeNodeAtPath===Object(removeNodeAtPath)&&Object.isExtensible(removeNodeAtPath)){Object.defineProperty(removeNodeAtPath,'__filemeta',{enumerable:true,configurable:true,value:{name:\"removeNodeAtPath\",filename:\"src/tree-data-utils.js\"}});}export function removeNode(_ref15){var treeData=_ref15.treeData,path=_ref15.path,getNodeKey=_ref15.getNodeKey,_ref15$ignoreCollapse=_ref15.ignoreCollapsed,ignoreCollapsed=_ref15$ignoreCollapse===void 0?true:_ref15$ignoreCollapse;var removedNode=null;var removedTreeIndex=null;var nextTreeData=changeNodeAtPath({treeData:treeData,path:path,getNodeKey:getNodeKey,ignoreCollapsed:ignoreCollapsed,newNode:function newNode(_ref16){var node=_ref16.node,treeIndex=_ref16.treeIndex;// Store the target node and delete it from the tree\nremovedNode=node;removedTreeIndex=treeIndex;return null;}});return{treeData:nextTreeData,node:removedNode,treeIndex:removedTreeIndex};}/**\n * Gets the node at the specified path\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n */if(typeof removeNode!=='undefined'&&removeNode&&removeNode===Object(removeNode)&&Object.isExtensible(removeNode)){Object.defineProperty(removeNode,'__filemeta',{enumerable:true,configurable:true,value:{name:\"removeNode\",filename:\"src/tree-data-utils.js\"}});}export function getNodeAtPath(_ref17){var treeData=_ref17.treeData,path=_ref17.path,getNodeKey=_ref17.getNodeKey,_ref17$ignoreCollapse=_ref17.ignoreCollapsed,ignoreCollapsed=_ref17$ignoreCollapse===void 0?true:_ref17$ignoreCollapse;var foundNodeInfo=null;try{changeNodeAtPath({treeData:treeData,path:path,getNodeKey:getNodeKey,ignoreCollapsed:ignoreCollapsed,newNode:function newNode(_ref18){var node=_ref18.node,treeIndex=_ref18.treeIndex;foundNodeInfo={node:node,treeIndex:treeIndex};return node;}});}catch(err){// Ignore the error -- the null return will be explanation enough\n}return foundNodeInfo;}/**\n * Adds the node to the specified parent and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {!Object} newNode - The node to insert\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The updated tree data\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n */if(typeof getNodeAtPath!=='undefined'&&getNodeAtPath&&getNodeAtPath===Object(getNodeAtPath)&&Object.isExtensible(getNodeAtPath)){Object.defineProperty(getNodeAtPath,'__filemeta',{enumerable:true,configurable:true,value:{name:\"getNodeAtPath\",filename:\"src/tree-data-utils.js\"}});}export function addNodeUnderParent(_ref19){var treeData=_ref19.treeData,newNode=_ref19.newNode,_ref19$parentKey=_ref19.parentKey,parentKey=_ref19$parentKey===void 0?null:_ref19$parentKey,getNodeKey=_ref19.getNodeKey,_ref19$ignoreCollapse=_ref19.ignoreCollapsed,ignoreCollapsed=_ref19$ignoreCollapse===void 0?true:_ref19$ignoreCollapse,_ref19$expandParent=_ref19.expandParent,expandParent=_ref19$expandParent===void 0?false:_ref19$expandParent,_ref19$addAsFirstChil=_ref19.addAsFirstChild,addAsFirstChild=_ref19$addAsFirstChil===void 0?false:_ref19$addAsFirstChil;if(parentKey===null){return{treeData:[].concat(_toConsumableArray(treeData||[]),[newNode]),treeIndex:(treeData||[]).length};}var insertedTreeIndex=null;var hasBeenAdded=false;var changedTreeData=map({treeData:treeData,getNodeKey:getNodeKey,ignoreCollapsed:ignoreCollapsed,callback:function callback(_ref20){var node=_ref20.node,treeIndex=_ref20.treeIndex,path=_ref20.path;var key=path?path[path.length-1]:null;// Return nodes that are not the parent as-is\nif(hasBeenAdded||key!==parentKey){return node;}hasBeenAdded=true;var parentNode=_objectSpread({},node);if(expandParent){parentNode.expanded=true;}// If no children exist yet, just add the single newNode\nif(!parentNode.children){insertedTreeIndex=treeIndex+1;return _objectSpread({},parentNode,{children:[newNode]});}if(typeof parentNode.children===\"function\"){throw new Error(\"Cannot add to children defined by a function\");}var nextTreeIndex=treeIndex+1;for(var i=0;i<parentNode.children.length;i+=1){nextTreeIndex+=1+getDescendantCount({node:parentNode.children[i],ignoreCollapsed:ignoreCollapsed});}insertedTreeIndex=nextTreeIndex;var children=addAsFirstChild?[newNode].concat(_toConsumableArray(parentNode.children)):[].concat(_toConsumableArray(parentNode.children),[newNode]);return _objectSpread({},parentNode,{children:children});}});if(!hasBeenAdded){throw new Error(\"No node found with the given key.\");}return{treeData:changedTreeData,treeIndex:insertedTreeIndex};}if(typeof addNodeUnderParent!=='undefined'&&addNodeUnderParent&&addNodeUnderParent===Object(addNodeUnderParent)&&Object.isExtensible(addNodeUnderParent)){Object.defineProperty(addNodeUnderParent,'__filemeta',{enumerable:true,configurable:true,value:{name:\"addNodeUnderParent\",filename:\"src/tree-data-utils.js\"}});}function addNodeAtDepthAndIndex(_ref21){var targetDepth=_ref21.targetDepth,minimumTreeIndex=_ref21.minimumTreeIndex,newNode=_ref21.newNode,ignoreCollapsed=_ref21.ignoreCollapsed,expandParent=_ref21.expandParent,_ref21$isPseudoRoot=_ref21.isPseudoRoot,isPseudoRoot=_ref21$isPseudoRoot===void 0?false:_ref21$isPseudoRoot,isLastChild=_ref21.isLastChild,node=_ref21.node,currentIndex=_ref21.currentIndex,currentDepth=_ref21.currentDepth,getNodeKey=_ref21.getNodeKey,_ref21$path=_ref21.path,path=_ref21$path===void 0?[]:_ref21$path;var selfPath=function selfPath(n){return isPseudoRoot?[]:[].concat(_toConsumableArray(path),[getNodeKey({node:n,treeIndex:currentIndex})]);};// If the current position is the only possible place to add, add it\nif(currentIndex>=minimumTreeIndex-1||isLastChild&&!(node.children&&node.children.length)){if(typeof node.children===\"function\"){throw new Error(\"Cannot add to children defined by a function\");}else{var extraNodeProps=expandParent?{expanded:true}:{};var _nextNode=_objectSpread({},node,extraNodeProps,{children:node.children?[newNode].concat(_toConsumableArray(node.children)):[newNode]});return{node:_nextNode,nextIndex:currentIndex+2,insertedTreeIndex:currentIndex+1,parentPath:selfPath(_nextNode),parentNode:isPseudoRoot?null:_nextNode};}}// If this is the target depth for the insertion,\n// i.e., where the newNode can be added to the current node's children\nif(currentDepth>=targetDepth-1){// Skip over nodes with no children or hidden children\nif(!node.children||typeof node.children===\"function\"||node.expanded!==true&&ignoreCollapsed&&!isPseudoRoot){return{node:node,nextIndex:currentIndex+1};}// Scan over the children to see if there's a place among them that fulfills\n// the minimumTreeIndex requirement\nvar _childIndex=currentIndex+1;var _insertedTreeIndex=null;var insertIndex=null;for(var i=0;i<node.children.length;i+=1){// If a valid location is found, mark it as the insertion location and\n// break out of the loop\nif(_childIndex>=minimumTreeIndex){_insertedTreeIndex=_childIndex;insertIndex=i;break;}// Increment the index by the child itself plus the number of descendants it has\n_childIndex+=1+getDescendantCount({node:node.children[i],ignoreCollapsed:ignoreCollapsed});}// If no valid indices to add the node were found\nif(insertIndex===null){// If the last position in this node's children is less than the minimum index\n// and there are more children on the level of this node, return without insertion\nif(_childIndex<minimumTreeIndex&&!isLastChild){return{node:node,nextIndex:_childIndex};}// Use the last position in the children array to insert the newNode\n_insertedTreeIndex=_childIndex;insertIndex=node.children.length;}// Insert the newNode at the insertIndex\nvar _nextNode2=_objectSpread({},node,{children:[].concat(_toConsumableArray(node.children.slice(0,insertIndex)),[newNode],_toConsumableArray(node.children.slice(insertIndex)))});// Return node with successful insert result\nreturn{node:_nextNode2,nextIndex:_childIndex,insertedTreeIndex:_insertedTreeIndex,parentPath:selfPath(_nextNode2),parentNode:isPseudoRoot?null:_nextNode2};}// Skip over nodes with no children or hidden children\nif(!node.children||typeof node.children===\"function\"||node.expanded!==true&&ignoreCollapsed&&!isPseudoRoot){return{node:node,nextIndex:currentIndex+1};}// Get all descendants\nvar insertedTreeIndex=null;var pathFragment=null;var parentNode=null;var childIndex=currentIndex+1;var newChildren=node.children;if(typeof newChildren!==\"function\"){newChildren=newChildren.map(function(child,i){if(insertedTreeIndex!==null){return child;}var mapResult=addNodeAtDepthAndIndex({targetDepth:targetDepth,minimumTreeIndex:minimumTreeIndex,newNode:newNode,ignoreCollapsed:ignoreCollapsed,expandParent:expandParent,isLastChild:isLastChild&&i===newChildren.length-1,node:child,currentIndex:childIndex,currentDepth:currentDepth+1,getNodeKey:getNodeKey,path:[]// Cannot determine the parent path until the children have been processed\n});if(\"insertedTreeIndex\"in mapResult){insertedTreeIndex=mapResult.insertedTreeIndex;parentNode=mapResult.parentNode;pathFragment=mapResult.parentPath;}childIndex=mapResult.nextIndex;return mapResult.node;});}var nextNode=_objectSpread({},node,{children:newChildren});var result={node:nextNode,nextIndex:childIndex};if(insertedTreeIndex!==null){result.insertedTreeIndex=insertedTreeIndex;result.parentPath=[].concat(_toConsumableArray(selfPath(nextNode)),_toConsumableArray(pathFragment));result.parentNode=parentNode;}return result;}/**\n * Insert a node into the tree at the given depth, after the minimum index\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n * @param {!Object} newNode - The node to insert into the tree\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node added\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\n * @return {Object} result.parentNode - The parent node of the inserted node\n */export function insertNode(_ref22){var treeData=_ref22.treeData,targetDepth=_ref22.depth,minimumTreeIndex=_ref22.minimumTreeIndex,newNode=_ref22.newNode,_ref22$getNodeKey=_ref22.getNodeKey,getNodeKey=_ref22$getNodeKey===void 0?function(){}:_ref22$getNodeKey,_ref22$ignoreCollapse=_ref22.ignoreCollapsed,ignoreCollapsed=_ref22$ignoreCollapse===void 0?true:_ref22$ignoreCollapse,_ref22$expandParent=_ref22.expandParent,expandParent=_ref22$expandParent===void 0?false:_ref22$expandParent;if(!treeData&&targetDepth===0){return{treeData:[newNode],treeIndex:0,path:[getNodeKey({node:newNode,treeIndex:0})],parentNode:null};}var insertResult=addNodeAtDepthAndIndex({targetDepth:targetDepth,minimumTreeIndex:minimumTreeIndex,newNode:newNode,ignoreCollapsed:ignoreCollapsed,expandParent:expandParent,getNodeKey:getNodeKey,isPseudoRoot:true,isLastChild:true,node:{children:treeData},currentIndex:-1,currentDepth:-1});if(!(\"insertedTreeIndex\"in insertResult)){throw new Error(\"No suitable position found to insert.\");}var treeIndex=insertResult.insertedTreeIndex;return{treeData:insertResult.node.children,treeIndex:treeIndex,path:[].concat(_toConsumableArray(insertResult.parentPath),[getNodeKey({node:newNode,treeIndex:treeIndex})]),parentNode:insertResult.parentNode};}/**\n * Get tree data flattened.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }}[] nodes - The node array\n */if(typeof insertNode!=='undefined'&&insertNode&&insertNode===Object(insertNode)&&Object.isExtensible(insertNode)){Object.defineProperty(insertNode,'__filemeta',{enumerable:true,configurable:true,value:{name:\"insertNode\",filename:\"src/tree-data-utils.js\"}});}export function getFlatDataFromTree(_ref23){var treeData=_ref23.treeData,getNodeKey=_ref23.getNodeKey,_ref23$ignoreCollapse=_ref23.ignoreCollapsed,ignoreCollapsed=_ref23$ignoreCollapse===void 0?true:_ref23$ignoreCollapse;if(!treeData||treeData.length<1){return[];}var flattened=[];walk({treeData:treeData,getNodeKey:getNodeKey,ignoreCollapsed:ignoreCollapsed,callback:function callback(nodeInfo){flattened.push(nodeInfo);}});return flattened;}/**\n * Generate a tree structure from flat data.\n *\n * @param {!Object[]} flatData\n * @param {!function=} getKey - Function to get the key from the nodeData\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\n *\n * @return {Object[]} treeData - The flat data represented as a tree\n */if(typeof getFlatDataFromTree!=='undefined'&&getFlatDataFromTree&&getFlatDataFromTree===Object(getFlatDataFromTree)&&Object.isExtensible(getFlatDataFromTree)){Object.defineProperty(getFlatDataFromTree,'__filemeta',{enumerable:true,configurable:true,value:{name:\"getFlatDataFromTree\",filename:\"src/tree-data-utils.js\"}});}export function getTreeFromFlatData(_ref24){var flatData=_ref24.flatData,_ref24$getKey=_ref24.getKey,getKey=_ref24$getKey===void 0?function(node){return node.id;}:_ref24$getKey,_ref24$getParentKey=_ref24.getParentKey,getParentKey=_ref24$getParentKey===void 0?function(node){return node.parentId;}:_ref24$getParentKey,_ref24$rootKey=_ref24.rootKey,rootKey=_ref24$rootKey===void 0?\"0\":_ref24$rootKey;if(!flatData){return[];}var childrenToParents={};flatData.forEach(function(child){var parentKey=getParentKey(child);if(parentKey in childrenToParents){childrenToParents[parentKey].push(child);}else{childrenToParents[parentKey]=[child];}});if(!(rootKey in childrenToParents)){return[];}var trav=function trav(parent){var parentKey=getKey(parent);if(parentKey in childrenToParents){return _objectSpread({},parent,{children:childrenToParents[parentKey].map(function(child){return trav(child);})});}return _objectSpread({},parent);};return childrenToParents[rootKey].map(function(child){return trav(child);});}/**\n * Check if a node is a descendant of another node.\n *\n * @param {!Object} older - Potential ancestor of younger node\n * @param {!Object} younger - Potential descendant of older node\n *\n * @return {boolean}\n */if(typeof getTreeFromFlatData!=='undefined'&&getTreeFromFlatData&&getTreeFromFlatData===Object(getTreeFromFlatData)&&Object.isExtensible(getTreeFromFlatData)){Object.defineProperty(getTreeFromFlatData,'__filemeta',{enumerable:true,configurable:true,value:{name:\"getTreeFromFlatData\",filename:\"src/tree-data-utils.js\"}});}export function isDescendant(older,younger){return!!older.children&&typeof older.children!==\"function\"&&older.children.some(function(child){return child===younger||isDescendant(child,younger);});}/**\n * Get the maximum depth of the children (the depth of the root node is 0).\n *\n * @param {!Object} node - Node in the tree\n * @param {?number} depth - The current depth\n *\n * @return {number} maxDepth - The deepest depth in the tree\n */if(typeof isDescendant!=='undefined'&&isDescendant&&isDescendant===Object(isDescendant)&&Object.isExtensible(isDescendant)){Object.defineProperty(isDescendant,'__filemeta',{enumerable:true,configurable:true,value:{name:\"isDescendant\",filename:\"src/tree-data-utils.js\"}});}export function getDepth(node){var depth=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;if(!node.children){return depth;}if(typeof node.children===\"function\"){return depth+1;}return node.children.reduce(function(deepest,child){return Math.max(deepest,getDepth(child,depth+1));},depth);}/**\n * Find nodes matching a search query in the tree,\n *\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {!Object[]} treeData - Tree data\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n * @param {?number} searchFocusOffset - The offset of the match to focus on\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n *\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n *                               it will be the same as the original tree data.\n */if(typeof getDepth!=='undefined'&&getDepth&&getDepth===Object(getDepth)&&Object.isExtensible(getDepth)){Object.defineProperty(getDepth,'__filemeta',{enumerable:true,configurable:true,value:{name:\"getDepth\",filename:\"src/tree-data-utils.js\"}});}export function find(_ref25){var getNodeKey=_ref25.getNodeKey,treeData=_ref25.treeData,searchQuery=_ref25.searchQuery,searchMethod=_ref25.searchMethod,searchFocusOffset=_ref25.searchFocusOffset,_ref25$expandAllMatch=_ref25.expandAllMatchPaths,expandAllMatchPaths=_ref25$expandAllMatch===void 0?false:_ref25$expandAllMatch,_ref25$expandFocusMat=_ref25.expandFocusMatchPaths,expandFocusMatchPaths=_ref25$expandFocusMat===void 0?true:_ref25$expandFocusMat;var matchCount=0;var trav=function trav(_ref26){var _ref26$isPseudoRoot=_ref26.isPseudoRoot,isPseudoRoot=_ref26$isPseudoRoot===void 0?false:_ref26$isPseudoRoot,node=_ref26.node,currentIndex=_ref26.currentIndex,_ref26$path=_ref26.path,path=_ref26$path===void 0?[]:_ref26$path;var matches=[];var isSelfMatch=false;var hasFocusMatch=false;// The pseudo-root is not considered in the path\nvar selfPath=isPseudoRoot?[]:[].concat(_toConsumableArray(path),[getNodeKey({node:node,treeIndex:currentIndex})]);var extraInfo=isPseudoRoot?null:{path:selfPath,treeIndex:currentIndex};// Nodes with with children that aren't lazy\nvar hasChildren=node.children&&typeof node.children!==\"function\"&&node.children.length>0;// Examine the current node to see if it is a match\nif(!isPseudoRoot&&searchMethod(_objectSpread({},extraInfo,{node:node,searchQuery:searchQuery}))){if(matchCount===searchFocusOffset){hasFocusMatch=true;}// Keep track of the number of matching nodes, so we know when the searchFocusOffset\n//  is reached\nmatchCount+=1;// We cannot add this node to the matches right away, as it may be changed\n//  during the search of the descendants. The entire node is used in\n//  comparisons between nodes inside the `matches` and `treeData` results\n//  of this method (`find`)\nisSelfMatch=true;}var childIndex=currentIndex;var newNode=_objectSpread({},node);if(hasChildren){// Get all descendants\nnewNode.children=newNode.children.map(function(child){var mapResult=trav({node:child,currentIndex:childIndex+1,path:selfPath});// Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n// if the child is expanded.\n//\n// The child could have been expanded from the start,\n// or expanded due to a matching node being found in its descendants\nif(mapResult.node.expanded){childIndex=mapResult.treeIndex;}else{childIndex+=1;}if(mapResult.matches.length>0||mapResult.hasFocusMatch){matches=[].concat(_toConsumableArray(matches),_toConsumableArray(mapResult.matches));if(mapResult.hasFocusMatch){hasFocusMatch=true;}// Expand the current node if it has descendants matching the search\n// and the settings are set to do so.\nif(expandAllMatchPaths&&mapResult.matches.length>0||(expandAllMatchPaths||expandFocusMatchPaths)&&mapResult.hasFocusMatch){newNode.expanded=true;}}return mapResult.node;});}// Cannot assign a treeIndex to hidden nodes\nif(!isPseudoRoot&&!newNode.expanded){matches=matches.map(function(match){return _objectSpread({},match,{treeIndex:null});});}// Add this node to the matches if it fits the search criteria.\n// This is performed at the last minute so newNode can be sent in its final form.\nif(isSelfMatch){matches=[_objectSpread({},extraInfo,{node:newNode})].concat(_toConsumableArray(matches));}return{node:matches.length>0?newNode:node,matches:matches,hasFocusMatch:hasFocusMatch,treeIndex:childIndex};};var result=trav({node:{children:treeData},isPseudoRoot:true,currentIndex:-1});return{matches:result.matches,treeData:result.node.children};}if(typeof find!=='undefined'&&find&&find===Object(find)&&Object.isExtensible(find)){Object.defineProperty(find,'__filemeta',{enumerable:true,configurable:true,value:{name:\"find\",filename:\"src/tree-data-utils.js\"}});}export function treeToList(arr){var treeList=arr||[];//末级节点\nvar leafs=[];//根\nvar roots=[];//所有节点\nvar list=[];for(var i=0;i<treeList.length;i++){var d=treeList[i];if(!d){continue;}var childrens=d.children||[];d.__depth=0;list.push(d);roots.push(d);if(childrens.length>0){getChildren(d,0);}else{leafs.push(d);}}function getChildren(d,depth){var tempArr=d.children||[];for(var _i=0;_i<tempArr.length;_i++){var _d=tempArr[_i];var _childrens=_d.children||[];_d.__depth=depth+1;list.push(_d);if(_childrens.length>0){getChildren(_d,depth+1);}else{leafs.push(_d);}}}return{list:list,leafs:leafs,roots:roots};}if(typeof treeToList!=='undefined'&&treeToList&&treeToList===Object(treeToList)&&Object.isExtensible(treeToList)){Object.defineProperty(treeToList,'__filemeta',{enumerable:true,configurable:true,value:{name:\"treeToList\",filename:\"src/tree-data-utils.js\"}});}export function getDataListWithExpanded(list){var expandedKeys=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var rowKey=arguments.length>2?arguments[2]:undefined;var arr=[];for(var i=0;i<list.length;i++){var d=list[i];d.__depth=0;arr.push(d);if(expandedKeys.indexOf(d[rowKey])>-1){if(d.children){setChildren(d,0);}}}function setChildren(c,depth){var cArr=c.children;for(var _i2=0;_i2<cArr.length;_i2++){var _d2=cArr[_i2];_d2.__depth=depth+1;arr.push(_d2);if(expandedKeys.indexOf(_d2[rowKey])>-1){if(_d2.children){setChildren(_d2,depth+1);}}}}return arr;}if(typeof getDataListWithExpanded!=='undefined'&&getDataListWithExpanded&&getDataListWithExpanded===Object(getDataListWithExpanded)&&Object.isExtensible(getDataListWithExpanded)){Object.defineProperty(getDataListWithExpanded,'__filemeta',{enumerable:true,configurable:true,value:{name:\"getDataListWithExpanded\",filename:\"src/tree-data-utils.js\"}});}",{"version":3,"sources":["/home/nexx/develop/tablex/src/tree-data-utils.js"],"names":["getNodeDataAtTreeIndexOrNextIndex","targetIndex","node","currentIndex","getNodeKey","path","lowerSiblingCounts","ignoreCollapsed","isPseudoRoot","selfPath","treeIndex","children","expanded","nextIndex","childIndex","childCount","length","i","result","getDescendantCount","walkDescendants","callback","parentNode","selfInfo","callbackResult","mapDescendants","nextNode","map","child","mapResult","getVisibleNodeCount","treeData","traverse","reduce","total","currentNode","getVisibleNodeInfoAtIndex","index","walk","toggleExpandedForAll","changeNodeAtPath","newNode","RESULT_MISS","currentTreeIndex","pathIndex","Error","nextTreeIndex","slice","removeNodeAtPath","removeNode","removedNode","removedTreeIndex","nextTreeData","getNodeAtPath","foundNodeInfo","err","addNodeUnderParent","parentKey","expandParent","addAsFirstChild","insertedTreeIndex","hasBeenAdded","changedTreeData","key","addNodeAtDepthAndIndex","targetDepth","minimumTreeIndex","isLastChild","currentDepth","n","extraNodeProps","parentPath","insertIndex","pathFragment","newChildren","insertNode","depth","insertResult","getFlatDataFromTree","flattened","nodeInfo","push","getTreeFromFlatData","flatData","getKey","id","getParentKey","parentId","rootKey","childrenToParents","forEach","trav","parent","isDescendant","older","younger","some","getDepth","deepest","Math","max","find","searchQuery","searchMethod","searchFocusOffset","expandAllMatchPaths","expandFocusMatchPaths","matchCount","matches","isSelfMatch","hasFocusMatch","extraInfo","hasChildren","match","treeToList","arr","treeList","leafs","roots","list","d","childrens","__depth","getChildren","tempArr","getDataListWithExpanded","expandedKeys","rowKey","indexOf","setChildren","c","cArr"],"mappings":"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","sourcesContent":["/**\n * Performs a depth-first traversal over all of the node descendants,\n * incrementing currentIndex by 1 for each\n */\nfunction getNodeDataAtTreeIndexOrNextIndex({\n  targetIndex,\n  node,\n  currentIndex,\n  getNodeKey,\n  path = [],\n  lowerSiblingCounts = [],\n  ignoreCollapsed = true,\n  isPseudoRoot = false\n}) {\n  // The pseudo-root is not considered in the path\n  const selfPath = !isPseudoRoot\n    ? [...path, getNodeKey({ node, treeIndex: currentIndex })]\n    : [];\n\n  // Return target node when found\n  if (currentIndex === targetIndex) {\n    return {\n      node,\n      lowerSiblingCounts,\n      path: selfPath\n    };\n  }\n\n  // Add one and continue for nodes with no children or hidden children\n  if (!node.children || (ignoreCollapsed && node.expanded !== true)) {\n    return { nextIndex: currentIndex + 1 };\n  }\n\n  // Iterate over each child and their descendants and return the\n  // target node if childIndex reaches the targetIndex\n  let childIndex = currentIndex + 1;\n  const childCount = node.children.length;\n  for (let i = 0; i < childCount; i += 1) {\n    const result = getNodeDataAtTreeIndexOrNextIndex({\n      ignoreCollapsed,\n      getNodeKey,\n      targetIndex,\n      node: node.children[i],\n      currentIndex: childIndex,\n      lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n      path: selfPath\n    });\n\n    if (result.node) {\n      return result;\n    }\n\n    childIndex = result.nextIndex;\n  }\n\n  // If the target node is not found, return the farthest traversed index\n  return { nextIndex: childIndex };\n}\n\nexport function getDescendantCount({ node, ignoreCollapsed = true }) {\n  return (\n    getNodeDataAtTreeIndexOrNextIndex({\n      getNodeKey: () => {},\n      ignoreCollapsed,\n      node,\n      currentIndex: 0,\n      targetIndex: -1\n    }).nextIndex - 1\n  );\n}\n\n/**\n * Walk all descendants of the given node, depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\nfunction walkDescendants({\n  callback,\n  getNodeKey,\n  ignoreCollapsed,\n  isPseudoRoot = false,\n  node,\n  parentNode = null,\n  currentIndex,\n  path = [],\n  lowerSiblingCounts = []\n}) {\n  // The pseudo-root is not considered in the path\n  const selfPath = isPseudoRoot\n    ? []\n    : [...path, getNodeKey({ node, treeIndex: currentIndex })];\n  const selfInfo = isPseudoRoot\n    ? null\n    : {\n        node,\n        parentNode,\n        path: selfPath,\n        lowerSiblingCounts,\n        treeIndex: currentIndex\n      };\n\n  if (!isPseudoRoot) {\n    const callbackResult = callback(selfInfo);\n\n    // Cut walk short if the callback returned false\n    if (callbackResult === false) {\n      return false;\n    }\n  }\n\n  // Return self on nodes with no children or hidden children\n  if (\n    !node.children ||\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return currentIndex;\n  }\n\n  // Get all descendants\n  let childIndex = currentIndex;\n  const childCount = node.children.length;\n  if (typeof node.children !== \"function\") {\n    for (let i = 0; i < childCount; i += 1) {\n      childIndex = walkDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        node: node.children[i],\n        parentNode: isPseudoRoot ? null : node,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n        path: selfPath\n      });\n\n      // Cut walk short if the callback returned false\n      if (childIndex === false) {\n        return false;\n      }\n    }\n  }\n\n  return childIndex;\n}\n\n/**\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\nfunction mapDescendants({\n  callback,\n  getNodeKey,\n  ignoreCollapsed,\n  isPseudoRoot = false,\n  node,\n  parentNode = null,\n  currentIndex,\n  path = [],\n  lowerSiblingCounts = []\n}) {\n  const nextNode = { ...node };\n\n  // The pseudo-root is not considered in the path\n  const selfPath = isPseudoRoot\n    ? []\n    : [...path, getNodeKey({ node: nextNode, treeIndex: currentIndex })];\n  const selfInfo = {\n    node: nextNode,\n    parentNode,\n    path: selfPath,\n    lowerSiblingCounts,\n    treeIndex: currentIndex\n  };\n\n  // Return self on nodes with no children or hidden children\n  if (\n    !nextNode.children ||\n    (nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return {\n      treeIndex: currentIndex,\n      node: callback(selfInfo)\n    };\n  }\n\n  // Get all descendants\n  let childIndex = currentIndex;\n  const childCount = nextNode.children.length;\n  if (typeof nextNode.children !== \"function\") {\n    nextNode.children = nextNode.children.map((child, i) => {\n      const mapResult = mapDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        node: child,\n        parentNode: isPseudoRoot ? null : nextNode,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n        path: selfPath\n      });\n      childIndex = mapResult.treeIndex;\n\n      return mapResult.node;\n    });\n  }\n\n  return {\n    node: callback(selfInfo),\n    treeIndex: childIndex\n  };\n}\n\n/**\n * Count all the visible (expanded) descendants in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n *\n * @return {number} count\n */\nexport function getVisibleNodeCount({ treeData }) {\n  const traverse = node => {\n    if (\n      !node.children ||\n      node.expanded !== true ||\n      typeof node.children === \"function\"\n    ) {\n      return 1;\n    }\n\n    return (\n      1 +\n      node.children.reduce(\n        (total, currentNode) => total + traverse(currentNode),\n        0\n      )\n    );\n  };\n\n  return treeData.reduce(\n    (total, currentNode) => total + traverse(currentNode),\n    0\n  );\n}\n\n/**\n * Get the <targetIndex>th visible node in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} targetIndex - The index of the node to search for\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }|null} node - The node at targetIndex, or null if not found\n */\nexport function getVisibleNodeInfoAtIndex({\n  treeData,\n  index: targetIndex,\n  getNodeKey\n}) {\n  if (!treeData || treeData.length < 1) {\n    return null;\n  }\n\n  // Call the tree traversal with a pseudo-root node\n  const result = getNodeDataAtTreeIndexOrNextIndex({\n    targetIndex,\n    getNodeKey,\n    node: {\n      children: treeData,\n      expanded: true\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: [],\n    isPseudoRoot: true\n  });\n\n  if (result.node) {\n    return result;\n  }\n\n  return null;\n}\n\n/**\n * Walk descendants depth-first and call a callback on each\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return void\n */\nexport function walk({\n  treeData,\n  getNodeKey,\n  callback,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return;\n  }\n\n  walkDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  });\n}\n\n/**\n * Perform a depth-first transversal of the descendants and\n *  make a change to every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function map({\n  treeData,\n  getNodeKey,\n  callback,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return [];\n  }\n\n  return mapDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  }).node.children;\n}\n\n/**\n * Expand or close every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {?boolean} expanded - Whether the node is expanded or not\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function toggleExpandedForAll({ treeData, expanded = true }) {\n  return map({\n    treeData,\n    callback: ({ node }) => ({ ...node, expanded }),\n    getNodeKey: ({ treeIndex }) => treeIndex,\n    ignoreCollapsed: false\n  });\n}\n\n/**\n * Replaces node at path with object, or callback-defined object\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function changeNodeAtPath({\n  treeData,\n  path,\n  newNode,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  const RESULT_MISS = \"RESULT_MISS\";\n  const traverse = ({\n    isPseudoRoot = false,\n    node,\n    currentTreeIndex,\n    pathIndex\n  }) => {\n    if (\n      !isPseudoRoot &&\n      getNodeKey({ node, treeIndex: currentTreeIndex }) !== path[pathIndex]\n    ) {\n      return RESULT_MISS;\n    }\n\n    if (pathIndex >= path.length - 1) {\n      // If this is the final location in the path, return its changed form\n      return typeof newNode === \"function\"\n        ? newNode({ node, treeIndex: currentTreeIndex })\n        : newNode;\n    }\n    if (!node.children) {\n      // If this node is part of the path, but has no children, return the unchanged node\n      throw new Error(\"Path referenced children of node with no children.\");\n    }\n\n    let nextTreeIndex = currentTreeIndex + 1;\n    for (let i = 0; i < node.children.length; i += 1) {\n      const result = traverse({\n        node: node.children[i],\n        currentTreeIndex: nextTreeIndex,\n        pathIndex: pathIndex + 1\n      });\n\n      // If the result went down the correct path\n      if (result !== RESULT_MISS) {\n        if (result) {\n          // If the result was truthy (in this case, an object),\n          //  pass it to the next level of recursion up\n          return {\n            ...node,\n            children: [\n              ...node.children.slice(0, i),\n              result,\n              ...node.children.slice(i + 1)\n            ]\n          };\n        }\n        // If the result was falsy (returned from the newNode function), then\n        //  delete the node from the array.\n        return {\n          ...node,\n          children: [\n            ...node.children.slice(0, i),\n            ...node.children.slice(i + 1)\n          ]\n        };\n      }\n\n      nextTreeIndex +=\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\n    }\n\n    return RESULT_MISS;\n  };\n\n  // Use a pseudo-root node in the beginning traversal\n  const result = traverse({\n    node: { children: treeData },\n    currentTreeIndex: -1,\n    pathIndex: -1,\n    isPseudoRoot: true\n  });\n\n  if (result === RESULT_MISS) {\n    throw new Error(\"No node found at the given path.\");\n  }\n\n  return result.children;\n}\n\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The tree data with the node removed\n */\nexport function removeNodeAtPath({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  return changeNodeAtPath({\n    treeData,\n    path,\n    getNodeKey,\n    ignoreCollapsed,\n    newNode: null // Delete the node\n  });\n}\n\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node removed\n * @return {Object} result.node - The node that was removed\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\n */\nexport function removeNode({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  let removedNode = null;\n  let removedTreeIndex = null;\n  const nextTreeData = changeNodeAtPath({\n    treeData,\n    path,\n    getNodeKey,\n    ignoreCollapsed,\n    newNode: ({ node, treeIndex }) => {\n      // Store the target node and delete it from the tree\n      removedNode = node;\n      removedTreeIndex = treeIndex;\n\n      return null;\n    }\n  });\n\n  return {\n    treeData: nextTreeData,\n    node: removedNode,\n    treeIndex: removedTreeIndex\n  };\n}\n\n/**\n * Gets the node at the specified path\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n */\nexport function getNodeAtPath({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  let foundNodeInfo = null;\n\n  try {\n    changeNodeAtPath({\n      treeData,\n      path,\n      getNodeKey,\n      ignoreCollapsed,\n      newNode: ({ node, treeIndex }) => {\n        foundNodeInfo = { node, treeIndex };\n        return node;\n      }\n    });\n  } catch (err) {\n    // Ignore the error -- the null return will be explanation enough\n  }\n\n  return foundNodeInfo;\n}\n\n/**\n * Adds the node to the specified parent and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {!Object} newNode - The node to insert\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The updated tree data\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n */\nexport function addNodeUnderParent({\n  treeData,\n  newNode,\n  parentKey = null,\n  getNodeKey,\n  ignoreCollapsed = true,\n  expandParent = false,\n  addAsFirstChild = false\n}) {\n  if (parentKey === null) {\n    return {\n      treeData: [...(treeData || []), newNode],\n      treeIndex: (treeData || []).length\n    };\n  }\n\n  let insertedTreeIndex = null;\n  let hasBeenAdded = false;\n  const changedTreeData = map({\n    treeData,\n    getNodeKey,\n    ignoreCollapsed,\n    callback: ({ node, treeIndex, path }) => {\n      const key = path ? path[path.length - 1] : null;\n      // Return nodes that are not the parent as-is\n      if (hasBeenAdded || key !== parentKey) {\n        return node;\n      }\n      hasBeenAdded = true;\n\n      const parentNode = {\n        ...node\n      };\n\n      if (expandParent) {\n        parentNode.expanded = true;\n      }\n\n      // If no children exist yet, just add the single newNode\n      if (!parentNode.children) {\n        insertedTreeIndex = treeIndex + 1;\n        return {\n          ...parentNode,\n          children: [newNode]\n        };\n      }\n\n      if (typeof parentNode.children === \"function\") {\n        throw new Error(\"Cannot add to children defined by a function\");\n      }\n\n      let nextTreeIndex = treeIndex + 1;\n      for (let i = 0; i < parentNode.children.length; i += 1) {\n        nextTreeIndex +=\n          1 +\n          getDescendantCount({ node: parentNode.children[i], ignoreCollapsed });\n      }\n\n      insertedTreeIndex = nextTreeIndex;\n\n      const children = addAsFirstChild\n        ? [newNode, ...parentNode.children]\n        : [...parentNode.children, newNode];\n\n      return {\n        ...parentNode,\n        children\n      };\n    }\n  });\n\n  if (!hasBeenAdded) {\n    throw new Error(\"No node found with the given key.\");\n  }\n\n  return {\n    treeData: changedTreeData,\n    treeIndex: insertedTreeIndex\n  };\n}\n\nfunction addNodeAtDepthAndIndex({\n  targetDepth,\n  minimumTreeIndex,\n  newNode,\n  ignoreCollapsed,\n  expandParent,\n  isPseudoRoot = false,\n  isLastChild,\n  node,\n  currentIndex,\n  currentDepth,\n  getNodeKey,\n  path = []\n}) {\n  const selfPath = n =>\n    isPseudoRoot\n      ? []\n      : [...path, getNodeKey({ node: n, treeIndex: currentIndex })];\n\n  // If the current position is the only possible place to add, add it\n  if (\n    currentIndex >= minimumTreeIndex - 1 ||\n    (isLastChild && !(node.children && node.children.length))\n  ) {\n    if (typeof node.children === \"function\") {\n      throw new Error(\"Cannot add to children defined by a function\");\n    } else {\n      const extraNodeProps = expandParent ? { expanded: true } : {};\n      const nextNode = {\n        ...node,\n\n        ...extraNodeProps,\n        children: node.children ? [newNode, ...node.children] : [newNode]\n      };\n\n      return {\n        node: nextNode,\n        nextIndex: currentIndex + 2,\n        insertedTreeIndex: currentIndex + 1,\n        parentPath: selfPath(nextNode),\n        parentNode: isPseudoRoot ? null : nextNode\n      };\n    }\n  }\n\n  // If this is the target depth for the insertion,\n  // i.e., where the newNode can be added to the current node's children\n  if (currentDepth >= targetDepth - 1) {\n    // Skip over nodes with no children or hidden children\n    if (\n      !node.children ||\n      typeof node.children === \"function\" ||\n      (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n    ) {\n      return { node, nextIndex: currentIndex + 1 };\n    }\n\n    // Scan over the children to see if there's a place among them that fulfills\n    // the minimumTreeIndex requirement\n    let childIndex = currentIndex + 1;\n    let insertedTreeIndex = null;\n    let insertIndex = null;\n    for (let i = 0; i < node.children.length; i += 1) {\n      // If a valid location is found, mark it as the insertion location and\n      // break out of the loop\n      if (childIndex >= minimumTreeIndex) {\n        insertedTreeIndex = childIndex;\n        insertIndex = i;\n        break;\n      }\n\n      // Increment the index by the child itself plus the number of descendants it has\n      childIndex +=\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\n    }\n\n    // If no valid indices to add the node were found\n    if (insertIndex === null) {\n      // If the last position in this node's children is less than the minimum index\n      // and there are more children on the level of this node, return without insertion\n      if (childIndex < minimumTreeIndex && !isLastChild) {\n        return { node, nextIndex: childIndex };\n      }\n\n      // Use the last position in the children array to insert the newNode\n      insertedTreeIndex = childIndex;\n      insertIndex = node.children.length;\n    }\n\n    // Insert the newNode at the insertIndex\n    const nextNode = {\n      ...node,\n      children: [\n        ...node.children.slice(0, insertIndex),\n        newNode,\n        ...node.children.slice(insertIndex)\n      ]\n    };\n\n    // Return node with successful insert result\n    return {\n      node: nextNode,\n      nextIndex: childIndex,\n      insertedTreeIndex,\n      parentPath: selfPath(nextNode),\n      parentNode: isPseudoRoot ? null : nextNode\n    };\n  }\n\n  // Skip over nodes with no children or hidden children\n  if (\n    !node.children ||\n    typeof node.children === \"function\" ||\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return { node, nextIndex: currentIndex + 1 };\n  }\n\n  // Get all descendants\n  let insertedTreeIndex = null;\n  let pathFragment = null;\n  let parentNode = null;\n  let childIndex = currentIndex + 1;\n  let newChildren = node.children;\n  if (typeof newChildren !== \"function\") {\n    newChildren = newChildren.map((child, i) => {\n      if (insertedTreeIndex !== null) {\n        return child;\n      }\n\n      const mapResult = addNodeAtDepthAndIndex({\n        targetDepth,\n        minimumTreeIndex,\n        newNode,\n        ignoreCollapsed,\n        expandParent,\n        isLastChild: isLastChild && i === newChildren.length - 1,\n        node: child,\n        currentIndex: childIndex,\n        currentDepth: currentDepth + 1,\n        getNodeKey,\n        path: [] // Cannot determine the parent path until the children have been processed\n      });\n\n      if (\"insertedTreeIndex\" in mapResult) {\n        ({\n          insertedTreeIndex,\n          parentNode,\n          parentPath: pathFragment\n        } = mapResult);\n      }\n\n      childIndex = mapResult.nextIndex;\n\n      return mapResult.node;\n    });\n  }\n\n  const nextNode = { ...node, children: newChildren };\n  const result = {\n    node: nextNode,\n    nextIndex: childIndex\n  };\n\n  if (insertedTreeIndex !== null) {\n    result.insertedTreeIndex = insertedTreeIndex;\n    result.parentPath = [...selfPath(nextNode), ...pathFragment];\n    result.parentNode = parentNode;\n  }\n\n  return result;\n}\n\n/**\n * Insert a node into the tree at the given depth, after the minimum index\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n * @param {!Object} newNode - The node to insert into the tree\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node added\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\n * @return {Object} result.parentNode - The parent node of the inserted node\n */\nexport function insertNode({\n  treeData,\n  depth: targetDepth,\n  minimumTreeIndex,\n  newNode,\n  getNodeKey = () => {},\n  ignoreCollapsed = true,\n  expandParent = false\n}) {\n  if (!treeData && targetDepth === 0) {\n    return {\n      treeData: [newNode],\n      treeIndex: 0,\n      path: [getNodeKey({ node: newNode, treeIndex: 0 })],\n      parentNode: null\n    };\n  }\n\n  const insertResult = addNodeAtDepthAndIndex({\n    targetDepth,\n    minimumTreeIndex,\n    newNode,\n    ignoreCollapsed,\n    expandParent,\n    getNodeKey,\n    isPseudoRoot: true,\n    isLastChild: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    currentDepth: -1\n  });\n\n  if (!(\"insertedTreeIndex\" in insertResult)) {\n    throw new Error(\"No suitable position found to insert.\");\n  }\n\n  const treeIndex = insertResult.insertedTreeIndex;\n  return {\n    treeData: insertResult.node.children,\n    treeIndex,\n    path: [\n      ...insertResult.parentPath,\n      getNodeKey({ node: newNode, treeIndex })\n    ],\n    parentNode: insertResult.parentNode\n  };\n}\n\n/**\n * Get tree data flattened.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }}[] nodes - The node array\n */\nexport function getFlatDataFromTree({\n  treeData,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return [];\n  }\n\n  const flattened = [];\n  walk({\n    treeData,\n    getNodeKey,\n    ignoreCollapsed,\n    callback: nodeInfo => {\n      flattened.push(nodeInfo);\n    }\n  });\n\n  return flattened;\n}\n\n/**\n * Generate a tree structure from flat data.\n *\n * @param {!Object[]} flatData\n * @param {!function=} getKey - Function to get the key from the nodeData\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\n *\n * @return {Object[]} treeData - The flat data represented as a tree\n */\nexport function getTreeFromFlatData({\n  flatData,\n  getKey = node => node.id,\n  getParentKey = node => node.parentId,\n  rootKey = \"0\"\n}) {\n  if (!flatData) {\n    return [];\n  }\n\n  const childrenToParents = {};\n  flatData.forEach(child => {\n    const parentKey = getParentKey(child);\n\n    if (parentKey in childrenToParents) {\n      childrenToParents[parentKey].push(child);\n    } else {\n      childrenToParents[parentKey] = [child];\n    }\n  });\n\n  if (!(rootKey in childrenToParents)) {\n    return [];\n  }\n\n  const trav = parent => {\n    const parentKey = getKey(parent);\n    if (parentKey in childrenToParents) {\n      return {\n        ...parent,\n        children: childrenToParents[parentKey].map(child => trav(child))\n      };\n    }\n\n    return { ...parent };\n  };\n\n  return childrenToParents[rootKey].map(child => trav(child));\n}\n\n/**\n * Check if a node is a descendant of another node.\n *\n * @param {!Object} older - Potential ancestor of younger node\n * @param {!Object} younger - Potential descendant of older node\n *\n * @return {boolean}\n */\nexport function isDescendant(older, younger) {\n  return (\n    !!older.children &&\n    typeof older.children !== \"function\" &&\n    older.children.some(\n      child => child === younger || isDescendant(child, younger)\n    )\n  );\n}\n\n/**\n * Get the maximum depth of the children (the depth of the root node is 0).\n *\n * @param {!Object} node - Node in the tree\n * @param {?number} depth - The current depth\n *\n * @return {number} maxDepth - The deepest depth in the tree\n */\nexport function getDepth(node, depth = 0) {\n  if (!node.children) {\n    return depth;\n  }\n\n  if (typeof node.children === \"function\") {\n    return depth + 1;\n  }\n\n  return node.children.reduce(\n    (deepest, child) => Math.max(deepest, getDepth(child, depth + 1)),\n    depth\n  );\n}\n\n/**\n * Find nodes matching a search query in the tree,\n *\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {!Object[]} treeData - Tree data\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n * @param {?number} searchFocusOffset - The offset of the match to focus on\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n *\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n *                               it will be the same as the original tree data.\n */\nexport function find({\n  getNodeKey,\n  treeData,\n  searchQuery,\n  searchMethod,\n  searchFocusOffset,\n  expandAllMatchPaths = false,\n  expandFocusMatchPaths = true\n}) {\n  let matchCount = 0;\n  const trav = ({ isPseudoRoot = false, node, currentIndex, path = [] }) => {\n    let matches = [];\n    let isSelfMatch = false;\n    let hasFocusMatch = false;\n    // The pseudo-root is not considered in the path\n    const selfPath = isPseudoRoot\n      ? []\n      : [...path, getNodeKey({ node, treeIndex: currentIndex })];\n    const extraInfo = isPseudoRoot\n      ? null\n      : {\n          path: selfPath,\n          treeIndex: currentIndex\n        };\n\n    // Nodes with with children that aren't lazy\n    const hasChildren =\n      node.children &&\n      typeof node.children !== \"function\" &&\n      node.children.length > 0;\n\n    // Examine the current node to see if it is a match\n    if (!isPseudoRoot && searchMethod({ ...extraInfo, node, searchQuery })) {\n      if (matchCount === searchFocusOffset) {\n        hasFocusMatch = true;\n      }\n\n      // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n      //  is reached\n      matchCount += 1;\n\n      // We cannot add this node to the matches right away, as it may be changed\n      //  during the search of the descendants. The entire node is used in\n      //  comparisons between nodes inside the `matches` and `treeData` results\n      //  of this method (`find`)\n      isSelfMatch = true;\n    }\n\n    let childIndex = currentIndex;\n    const newNode = { ...node };\n    if (hasChildren) {\n      // Get all descendants\n      newNode.children = newNode.children.map(child => {\n        const mapResult = trav({\n          node: child,\n          currentIndex: childIndex + 1,\n          path: selfPath\n        });\n\n        // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n        // if the child is expanded.\n        //\n        // The child could have been expanded from the start,\n        // or expanded due to a matching node being found in its descendants\n        if (mapResult.node.expanded) {\n          childIndex = mapResult.treeIndex;\n        } else {\n          childIndex += 1;\n        }\n\n        if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n          matches = [...matches, ...mapResult.matches];\n          if (mapResult.hasFocusMatch) {\n            hasFocusMatch = true;\n          }\n\n          // Expand the current node if it has descendants matching the search\n          // and the settings are set to do so.\n          if (\n            (expandAllMatchPaths && mapResult.matches.length > 0) ||\n            ((expandAllMatchPaths || expandFocusMatchPaths) &&\n              mapResult.hasFocusMatch)\n          ) {\n            newNode.expanded = true;\n          }\n        }\n\n        return mapResult.node;\n      });\n    }\n\n    // Cannot assign a treeIndex to hidden nodes\n    if (!isPseudoRoot && !newNode.expanded) {\n      matches = matches.map(match => ({\n        ...match,\n        treeIndex: null\n      }));\n    }\n\n    // Add this node to the matches if it fits the search criteria.\n    // This is performed at the last minute so newNode can be sent in its final form.\n    if (isSelfMatch) {\n      matches = [{ ...extraInfo, node: newNode }, ...matches];\n    }\n\n    return {\n      node: matches.length > 0 ? newNode : node,\n      matches,\n      hasFocusMatch,\n      treeIndex: childIndex\n    };\n  };\n\n  const result = trav({\n    node: { children: treeData },\n    isPseudoRoot: true,\n    currentIndex: -1\n  });\n\n  return {\n    matches: result.matches,\n    treeData: result.node.children\n  };\n}\n\nexport function treeToList(arr) {\n  let treeList = arr || [];\n\n  //末级节点\n  let leafs = [];\n\n  //根\n  let roots = [];\n\n  //所有节点\n  let list = [];\n\n  for (let i = 0; i < treeList.length; i++) {\n    const d = treeList[i];\n\n    if (!d) {\n      continue;\n    }\n\n    const childrens = d.children || [];\n\n    d.__depth = 0;\n\n    list.push(d);\n    roots.push(d);\n\n    if (childrens.length > 0) {\n      getChildren(d, 0);\n    } else {\n      leafs.push(d);\n    }\n  }\n\n  function getChildren(d, depth) {\n    const tempArr = d.children || [];\n\n    for (let i = 0; i < tempArr.length; i++) {\n      const d = tempArr[i];\n      const childrens = d.children || [];\n\n      d.__depth = depth + 1;\n\n      list.push(d);\n\n      if (childrens.length > 0) {\n        getChildren(d, depth + 1);\n      } else {\n        leafs.push(d);\n      }\n    }\n  }\n\n  return { list, leafs, roots };\n}\n\nexport function getDataListWithExpanded(list, expandedKeys = [], rowKey) {\n  let arr = [];\n\n  for (let i = 0; i < list.length; i++) {\n    let d = list[i];\n\n    d.__depth = 0;\n\n    arr.push(d);\n\n    if (expandedKeys.indexOf(d[rowKey]) > -1) {\n      if (d.children) {\n        setChildren(d, 0);\n      }\n    }\n  }\n\n  function setChildren(c, depth) {\n    let cArr = c.children;\n    for (let i = 0; i < cArr.length; i++) {\n      let d = cArr[i];\n      d.__depth = depth + 1;\n      arr.push(d);\n\n      if (expandedKeys.indexOf(d[rowKey]) > -1) {\n        if (d.children) {\n          setChildren(d, depth + 1);\n        }\n      }\n    }\n  }\n\n  return arr;\n}\n"]}]}