{"remainingRequest":"/home/nexx/develop/tablex/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/nexx/develop/tablex/node_modules/docz-core/node_modules/babel-loader/lib/index.js??ref--5-2!/home/nexx/develop/tablex/node_modules/source-map-loader/index.js!/home/nexx/develop/tablex/src/tree-data-utils.js","dependencies":[{"path":"/home/nexx/develop/tablex/src/tree-data-utils.js","mtime":1555823102531},{"path":"/home/nexx/develop/tablex/node_modules/cache-loader/dist/cjs.js","mtime":1555737869369},{"path":"/home/nexx/develop/tablex/node_modules/thread-loader/dist/cjs.js","mtime":1555737872026},{"path":"/home/nexx/develop/tablex/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1555737864633},{"path":"/home/nexx/develop/tablex/node_modules/source-map-loader/index.js","mtime":1555737871137}],"contextDependencies":[],"result":["import _objectSpread from \"/home/nexx/develop/tablex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"/home/nexx/develop/tablex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n(function () {\n  var enterModule = (typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal : require('react-hot-loader')).enterModule;\n  enterModule && enterModule(module);\n})();\n\n/**\n * Performs a depth-first traversal over all of the node descendants,\n * incrementing currentIndex by 1 for each\n */\nfunction getNodeDataAtTreeIndexOrNextIndex(_ref) {\n  var targetIndex = _ref.targetIndex,\n      node = _ref.node,\n      currentIndex = _ref.currentIndex,\n      getNodeKey = _ref.getNodeKey,\n      _ref$path = _ref.path,\n      path = _ref$path === void 0 ? [] : _ref$path,\n      _ref$lowerSiblingCoun = _ref.lowerSiblingCounts,\n      lowerSiblingCounts = _ref$lowerSiblingCoun === void 0 ? [] : _ref$lowerSiblingCoun,\n      _ref$ignoreCollapsed = _ref.ignoreCollapsed,\n      ignoreCollapsed = _ref$ignoreCollapsed === void 0 ? true : _ref$ignoreCollapsed,\n      _ref$isPseudoRoot = _ref.isPseudoRoot,\n      isPseudoRoot = _ref$isPseudoRoot === void 0 ? false : _ref$isPseudoRoot;\n  // The pseudo-root is not considered in the path\n  var selfPath = !isPseudoRoot ? [].concat(_toConsumableArray(path), [getNodeKey({\n    node: node,\n    treeIndex: currentIndex\n  })]) : []; // Return target node when found\n\n  if (currentIndex === targetIndex) {\n    return {\n      node: node,\n      lowerSiblingCounts: lowerSiblingCounts,\n      path: selfPath\n    };\n  } // Add one and continue for nodes with no children or hidden children\n\n\n  if (!node.children || ignoreCollapsed && node.expanded !== true) {\n    return {\n      nextIndex: currentIndex + 1\n    };\n  } // Iterate over each child and their descendants and return the\n  // target node if childIndex reaches the targetIndex\n\n\n  var childIndex = currentIndex + 1;\n  var childCount = node.children.length;\n\n  for (var i = 0; i < childCount; i += 1) {\n    var result = getNodeDataAtTreeIndexOrNextIndex({\n      ignoreCollapsed: ignoreCollapsed,\n      getNodeKey: getNodeKey,\n      targetIndex: targetIndex,\n      node: node.children[i],\n      currentIndex: childIndex,\n      lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n      path: selfPath\n    });\n\n    if (result.node) {\n      return result;\n    }\n\n    childIndex = result.nextIndex;\n  } // If the target node is not found, return the farthest traversed index\n\n\n  return {\n    nextIndex: childIndex\n  };\n}\n\nexport function getDescendantCount(_ref2) {\n  var node = _ref2.node,\n      _ref2$ignoreCollapsed = _ref2.ignoreCollapsed,\n      ignoreCollapsed = _ref2$ignoreCollapsed === void 0 ? true : _ref2$ignoreCollapsed;\n  return getNodeDataAtTreeIndexOrNextIndex({\n    getNodeKey: function getNodeKey() {},\n    ignoreCollapsed: ignoreCollapsed,\n    node: node,\n    currentIndex: 0,\n    targetIndex: -1\n  }).nextIndex - 1;\n}\n/**\n * Walk all descendants of the given node, depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\n\nif (typeof getDescendantCount !== 'undefined' && getDescendantCount && getDescendantCount === Object(getDescendantCount) && Object.isExtensible(getDescendantCount)) {\n  Object.defineProperty(getDescendantCount, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"getDescendantCount\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nfunction walkDescendants(_ref3) {\n  var callback = _ref3.callback,\n      getNodeKey = _ref3.getNodeKey,\n      ignoreCollapsed = _ref3.ignoreCollapsed,\n      _ref3$isPseudoRoot = _ref3.isPseudoRoot,\n      isPseudoRoot = _ref3$isPseudoRoot === void 0 ? false : _ref3$isPseudoRoot,\n      node = _ref3.node,\n      _ref3$parentNode = _ref3.parentNode,\n      parentNode = _ref3$parentNode === void 0 ? null : _ref3$parentNode,\n      currentIndex = _ref3.currentIndex,\n      _ref3$path = _ref3.path,\n      path = _ref3$path === void 0 ? [] : _ref3$path,\n      _ref3$lowerSiblingCou = _ref3.lowerSiblingCounts,\n      lowerSiblingCounts = _ref3$lowerSiblingCou === void 0 ? [] : _ref3$lowerSiblingCou;\n  // The pseudo-root is not considered in the path\n  var selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({\n    node: node,\n    treeIndex: currentIndex\n  })]);\n  var selfInfo = isPseudoRoot ? null : {\n    node: node,\n    parentNode: parentNode,\n    path: selfPath,\n    lowerSiblingCounts: lowerSiblingCounts,\n    treeIndex: currentIndex\n  };\n\n  if (!isPseudoRoot) {\n    var callbackResult = callback(selfInfo); // Cut walk short if the callback returned false\n\n    if (callbackResult === false) {\n      return false;\n    }\n  } // Return self on nodes with no children or hidden children\n\n\n  if (!node.children || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return currentIndex;\n  } // Get all descendants\n\n\n  var childIndex = currentIndex;\n  var childCount = node.children.length;\n\n  if (typeof node.children !== \"function\") {\n    for (var i = 0; i < childCount; i += 1) {\n      childIndex = walkDescendants({\n        callback: callback,\n        getNodeKey: getNodeKey,\n        ignoreCollapsed: ignoreCollapsed,\n        node: node.children[i],\n        parentNode: isPseudoRoot ? null : node,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n        path: selfPath\n      }); // Cut walk short if the callback returned false\n\n      if (childIndex === false) {\n        return false;\n      }\n    }\n  }\n\n  return childIndex;\n}\n/**\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\n\n\nfunction mapDescendants(_ref4) {\n  var callback = _ref4.callback,\n      getNodeKey = _ref4.getNodeKey,\n      ignoreCollapsed = _ref4.ignoreCollapsed,\n      _ref4$isPseudoRoot = _ref4.isPseudoRoot,\n      isPseudoRoot = _ref4$isPseudoRoot === void 0 ? false : _ref4$isPseudoRoot,\n      node = _ref4.node,\n      _ref4$parentNode = _ref4.parentNode,\n      parentNode = _ref4$parentNode === void 0 ? null : _ref4$parentNode,\n      currentIndex = _ref4.currentIndex,\n      _ref4$path = _ref4.path,\n      path = _ref4$path === void 0 ? [] : _ref4$path,\n      _ref4$lowerSiblingCou = _ref4.lowerSiblingCounts,\n      lowerSiblingCounts = _ref4$lowerSiblingCou === void 0 ? [] : _ref4$lowerSiblingCou;\n\n  var nextNode = _objectSpread({}, node); // The pseudo-root is not considered in the path\n\n\n  var selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({\n    node: nextNode,\n    treeIndex: currentIndex\n  })]);\n  var selfInfo = {\n    node: nextNode,\n    parentNode: parentNode,\n    path: selfPath,\n    lowerSiblingCounts: lowerSiblingCounts,\n    treeIndex: currentIndex\n  }; // Return self on nodes with no children or hidden children\n\n  if (!nextNode.children || nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return {\n      treeIndex: currentIndex,\n      node: callback(selfInfo)\n    };\n  } // Get all descendants\n\n\n  var childIndex = currentIndex;\n  var childCount = nextNode.children.length;\n\n  if (typeof nextNode.children !== \"function\") {\n    nextNode.children = nextNode.children.map(function (child, i) {\n      var mapResult = mapDescendants({\n        callback: callback,\n        getNodeKey: getNodeKey,\n        ignoreCollapsed: ignoreCollapsed,\n        node: child,\n        parentNode: isPseudoRoot ? null : nextNode,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n        path: selfPath\n      });\n      childIndex = mapResult.treeIndex;\n      return mapResult.node;\n    });\n  }\n\n  return {\n    node: callback(selfInfo),\n    treeIndex: childIndex\n  };\n}\n/**\n * Count all the visible (expanded) descendants in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n *\n * @return {number} count\n */\n\n\nexport function getVisibleNodeCount(_ref5) {\n  var treeData = _ref5.treeData;\n\n  var traverse = function traverse(node) {\n    if (!node.children || node.expanded !== true || typeof node.children === \"function\") {\n      return 1;\n    }\n\n    return 1 + node.children.reduce(function (total, currentNode) {\n      return total + traverse(currentNode);\n    }, 0);\n  };\n\n  return treeData.reduce(function (total, currentNode) {\n    return total + traverse(currentNode);\n  }, 0);\n}\n/**\n * Get the <targetIndex>th visible node in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} targetIndex - The index of the node to search for\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }|null} node - The node at targetIndex, or null if not found\n */\n\nif (typeof getVisibleNodeCount !== 'undefined' && getVisibleNodeCount && getVisibleNodeCount === Object(getVisibleNodeCount) && Object.isExtensible(getVisibleNodeCount)) {\n  Object.defineProperty(getVisibleNodeCount, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"getVisibleNodeCount\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nexport function getVisibleNodeInfoAtIndex(_ref6) {\n  var treeData = _ref6.treeData,\n      targetIndex = _ref6.index,\n      getNodeKey = _ref6.getNodeKey;\n\n  if (!treeData || treeData.length < 1) {\n    return null;\n  } // Call the tree traversal with a pseudo-root node\n\n\n  var result = getNodeDataAtTreeIndexOrNextIndex({\n    targetIndex: targetIndex,\n    getNodeKey: getNodeKey,\n    node: {\n      children: treeData,\n      expanded: true\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: [],\n    isPseudoRoot: true\n  });\n\n  if (result.node) {\n    return result;\n  }\n\n  return null;\n}\n/**\n * Walk descendants depth-first and call a callback on each\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return void\n */\n\nif (typeof getVisibleNodeInfoAtIndex !== 'undefined' && getVisibleNodeInfoAtIndex && getVisibleNodeInfoAtIndex === Object(getVisibleNodeInfoAtIndex) && Object.isExtensible(getVisibleNodeInfoAtIndex)) {\n  Object.defineProperty(getVisibleNodeInfoAtIndex, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"getVisibleNodeInfoAtIndex\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nexport function walk(_ref7) {\n  var treeData = _ref7.treeData,\n      getNodeKey = _ref7.getNodeKey,\n      callback = _ref7.callback,\n      _ref7$ignoreCollapsed = _ref7.ignoreCollapsed,\n      ignoreCollapsed = _ref7$ignoreCollapsed === void 0 ? true : _ref7$ignoreCollapsed;\n\n  if (!treeData || treeData.length < 1) {\n    return;\n  }\n\n  walkDescendants({\n    callback: callback,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    isPseudoRoot: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  });\n}\n/**\n * Perform a depth-first transversal of the descendants and\n *  make a change to every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\nif (typeof walk !== 'undefined' && walk && walk === Object(walk) && Object.isExtensible(walk)) {\n  Object.defineProperty(walk, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"walk\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nexport function map(_ref8) {\n  var treeData = _ref8.treeData,\n      getNodeKey = _ref8.getNodeKey,\n      callback = _ref8.callback,\n      _ref8$ignoreCollapsed = _ref8.ignoreCollapsed,\n      ignoreCollapsed = _ref8$ignoreCollapsed === void 0 ? true : _ref8$ignoreCollapsed;\n\n  if (!treeData || treeData.length < 1) {\n    return [];\n  }\n\n  return mapDescendants({\n    callback: callback,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    isPseudoRoot: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  }).node.children;\n}\n/**\n * Expand or close every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {?boolean} expanded - Whether the node is expanded or not\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\nif (typeof map !== 'undefined' && map && map === Object(map) && Object.isExtensible(map)) {\n  Object.defineProperty(map, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"map\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nexport function toggleExpandedForAll(_ref9) {\n  var treeData = _ref9.treeData,\n      _ref9$expanded = _ref9.expanded,\n      expanded = _ref9$expanded === void 0 ? true : _ref9$expanded;\n  return map({\n    treeData: treeData,\n    callback: function callback(_ref10) {\n      var node = _ref10.node;\n      return _objectSpread({}, node, {\n        expanded: expanded\n      });\n    },\n    getNodeKey: function getNodeKey(_ref11) {\n      var treeIndex = _ref11.treeIndex;\n      return treeIndex;\n    },\n    ignoreCollapsed: false\n  });\n}\n/**\n * Replaces node at path with object, or callback-defined object\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\nif (typeof toggleExpandedForAll !== 'undefined' && toggleExpandedForAll && toggleExpandedForAll === Object(toggleExpandedForAll) && Object.isExtensible(toggleExpandedForAll)) {\n  Object.defineProperty(toggleExpandedForAll, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"toggleExpandedForAll\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nexport function changeNodeAtPath(_ref12) {\n  var treeData = _ref12.treeData,\n      path = _ref12.path,\n      newNode = _ref12.newNode,\n      getNodeKey = _ref12.getNodeKey,\n      _ref12$ignoreCollapse = _ref12.ignoreCollapsed,\n      ignoreCollapsed = _ref12$ignoreCollapse === void 0 ? true : _ref12$ignoreCollapse;\n  var RESULT_MISS = \"RESULT_MISS\";\n\n  var traverse = function traverse(_ref13) {\n    var _ref13$isPseudoRoot = _ref13.isPseudoRoot,\n        isPseudoRoot = _ref13$isPseudoRoot === void 0 ? false : _ref13$isPseudoRoot,\n        node = _ref13.node,\n        currentTreeIndex = _ref13.currentTreeIndex,\n        pathIndex = _ref13.pathIndex;\n\n    if (!isPseudoRoot && getNodeKey({\n      node: node,\n      treeIndex: currentTreeIndex\n    }) !== path[pathIndex]) {\n      return RESULT_MISS;\n    }\n\n    if (pathIndex >= path.length - 1) {\n      // If this is the final location in the path, return its changed form\n      return typeof newNode === \"function\" ? newNode({\n        node: node,\n        treeIndex: currentTreeIndex\n      }) : newNode;\n    }\n\n    if (!node.children) {\n      // If this node is part of the path, but has no children, return the unchanged node\n      throw new Error(\"Path referenced children of node with no children.\");\n    }\n\n    var nextTreeIndex = currentTreeIndex + 1;\n\n    for (var i = 0; i < node.children.length; i += 1) {\n      var _result = traverse({\n        node: node.children[i],\n        currentTreeIndex: nextTreeIndex,\n        pathIndex: pathIndex + 1\n      }); // If the result went down the correct path\n\n\n      if (_result !== RESULT_MISS) {\n        if (_result) {\n          // If the result was truthy (in this case, an object),\n          //  pass it to the next level of recursion up\n          return _objectSpread({}, node, {\n            children: [].concat(_toConsumableArray(node.children.slice(0, i)), [_result], _toConsumableArray(node.children.slice(i + 1)))\n          });\n        } // If the result was falsy (returned from the newNode function), then\n        //  delete the node from the array.\n\n\n        return _objectSpread({}, node, {\n          children: [].concat(_toConsumableArray(node.children.slice(0, i)), _toConsumableArray(node.children.slice(i + 1)))\n        });\n      }\n\n      nextTreeIndex += 1 + getDescendantCount({\n        node: node.children[i],\n        ignoreCollapsed: ignoreCollapsed\n      });\n    }\n\n    return RESULT_MISS;\n  }; // Use a pseudo-root node in the beginning traversal\n\n\n  var result = traverse({\n    node: {\n      children: treeData\n    },\n    currentTreeIndex: -1,\n    pathIndex: -1,\n    isPseudoRoot: true\n  });\n\n  if (result === RESULT_MISS) {\n    throw new Error(\"No node found at the given path.\");\n  }\n\n  return result.children;\n}\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The tree data with the node removed\n */\n\nif (typeof changeNodeAtPath !== 'undefined' && changeNodeAtPath && changeNodeAtPath === Object(changeNodeAtPath) && Object.isExtensible(changeNodeAtPath)) {\n  Object.defineProperty(changeNodeAtPath, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"changeNodeAtPath\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nexport function removeNodeAtPath(_ref14) {\n  var treeData = _ref14.treeData,\n      path = _ref14.path,\n      getNodeKey = _ref14.getNodeKey,\n      _ref14$ignoreCollapse = _ref14.ignoreCollapsed,\n      ignoreCollapsed = _ref14$ignoreCollapse === void 0 ? true : _ref14$ignoreCollapse;\n  return changeNodeAtPath({\n    treeData: treeData,\n    path: path,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    newNode: null // Delete the node\n\n  });\n}\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node removed\n * @return {Object} result.node - The node that was removed\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\n */\n\nif (typeof removeNodeAtPath !== 'undefined' && removeNodeAtPath && removeNodeAtPath === Object(removeNodeAtPath) && Object.isExtensible(removeNodeAtPath)) {\n  Object.defineProperty(removeNodeAtPath, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"removeNodeAtPath\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nexport function removeNode(_ref15) {\n  var treeData = _ref15.treeData,\n      path = _ref15.path,\n      getNodeKey = _ref15.getNodeKey,\n      _ref15$ignoreCollapse = _ref15.ignoreCollapsed,\n      ignoreCollapsed = _ref15$ignoreCollapse === void 0 ? true : _ref15$ignoreCollapse;\n  var removedNode = null;\n  var removedTreeIndex = null;\n  var nextTreeData = changeNodeAtPath({\n    treeData: treeData,\n    path: path,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    newNode: function newNode(_ref16) {\n      var node = _ref16.node,\n          treeIndex = _ref16.treeIndex;\n      // Store the target node and delete it from the tree\n      removedNode = node;\n      removedTreeIndex = treeIndex;\n      return null;\n    }\n  });\n  return {\n    treeData: nextTreeData,\n    node: removedNode,\n    treeIndex: removedTreeIndex\n  };\n}\n/**\n * Gets the node at the specified path\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n */\n\nif (typeof removeNode !== 'undefined' && removeNode && removeNode === Object(removeNode) && Object.isExtensible(removeNode)) {\n  Object.defineProperty(removeNode, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"removeNode\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nexport function getNodeAtPath(_ref17) {\n  var treeData = _ref17.treeData,\n      path = _ref17.path,\n      getNodeKey = _ref17.getNodeKey,\n      _ref17$ignoreCollapse = _ref17.ignoreCollapsed,\n      ignoreCollapsed = _ref17$ignoreCollapse === void 0 ? true : _ref17$ignoreCollapse;\n  var foundNodeInfo = null;\n\n  try {\n    changeNodeAtPath({\n      treeData: treeData,\n      path: path,\n      getNodeKey: getNodeKey,\n      ignoreCollapsed: ignoreCollapsed,\n      newNode: function newNode(_ref18) {\n        var node = _ref18.node,\n            treeIndex = _ref18.treeIndex;\n        foundNodeInfo = {\n          node: node,\n          treeIndex: treeIndex\n        };\n        return node;\n      }\n    });\n  } catch (err) {// Ignore the error -- the null return will be explanation enough\n  }\n\n  return foundNodeInfo;\n}\n/**\n * Adds the node to the specified parent and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {!Object} newNode - The node to insert\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The updated tree data\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n */\n\nif (typeof getNodeAtPath !== 'undefined' && getNodeAtPath && getNodeAtPath === Object(getNodeAtPath) && Object.isExtensible(getNodeAtPath)) {\n  Object.defineProperty(getNodeAtPath, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"getNodeAtPath\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nexport function addNodeUnderParent(_ref19) {\n  var treeData = _ref19.treeData,\n      newNode = _ref19.newNode,\n      _ref19$parentKey = _ref19.parentKey,\n      parentKey = _ref19$parentKey === void 0 ? null : _ref19$parentKey,\n      getNodeKey = _ref19.getNodeKey,\n      _ref19$ignoreCollapse = _ref19.ignoreCollapsed,\n      ignoreCollapsed = _ref19$ignoreCollapse === void 0 ? true : _ref19$ignoreCollapse,\n      _ref19$expandParent = _ref19.expandParent,\n      expandParent = _ref19$expandParent === void 0 ? false : _ref19$expandParent,\n      _ref19$addAsFirstChil = _ref19.addAsFirstChild,\n      addAsFirstChild = _ref19$addAsFirstChil === void 0 ? false : _ref19$addAsFirstChil;\n\n  if (parentKey === null) {\n    return {\n      treeData: [].concat(_toConsumableArray(treeData || []), [newNode]),\n      treeIndex: (treeData || []).length\n    };\n  }\n\n  var insertedTreeIndex = null;\n  var hasBeenAdded = false;\n  var changedTreeData = map({\n    treeData: treeData,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    callback: function callback(_ref20) {\n      var node = _ref20.node,\n          treeIndex = _ref20.treeIndex,\n          path = _ref20.path;\n      var key = path ? path[path.length - 1] : null; // Return nodes that are not the parent as-is\n\n      if (hasBeenAdded || key !== parentKey) {\n        return node;\n      }\n\n      hasBeenAdded = true;\n\n      var parentNode = _objectSpread({}, node);\n\n      if (expandParent) {\n        parentNode.expanded = true;\n      } // If no children exist yet, just add the single newNode\n\n\n      if (!parentNode.children) {\n        insertedTreeIndex = treeIndex + 1;\n        return _objectSpread({}, parentNode, {\n          children: [newNode]\n        });\n      }\n\n      if (typeof parentNode.children === \"function\") {\n        throw new Error(\"Cannot add to children defined by a function\");\n      }\n\n      var nextTreeIndex = treeIndex + 1;\n\n      for (var i = 0; i < parentNode.children.length; i += 1) {\n        nextTreeIndex += 1 + getDescendantCount({\n          node: parentNode.children[i],\n          ignoreCollapsed: ignoreCollapsed\n        });\n      }\n\n      insertedTreeIndex = nextTreeIndex;\n      var children = addAsFirstChild ? [newNode].concat(_toConsumableArray(parentNode.children)) : [].concat(_toConsumableArray(parentNode.children), [newNode]);\n      return _objectSpread({}, parentNode, {\n        children: children\n      });\n    }\n  });\n\n  if (!hasBeenAdded) {\n    throw new Error(\"No node found with the given key.\");\n  }\n\n  return {\n    treeData: changedTreeData,\n    treeIndex: insertedTreeIndex\n  };\n}\n\nif (typeof addNodeUnderParent !== 'undefined' && addNodeUnderParent && addNodeUnderParent === Object(addNodeUnderParent) && Object.isExtensible(addNodeUnderParent)) {\n  Object.defineProperty(addNodeUnderParent, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"addNodeUnderParent\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nfunction addNodeAtDepthAndIndex(_ref21) {\n  var targetDepth = _ref21.targetDepth,\n      minimumTreeIndex = _ref21.minimumTreeIndex,\n      newNode = _ref21.newNode,\n      ignoreCollapsed = _ref21.ignoreCollapsed,\n      expandParent = _ref21.expandParent,\n      _ref21$isPseudoRoot = _ref21.isPseudoRoot,\n      isPseudoRoot = _ref21$isPseudoRoot === void 0 ? false : _ref21$isPseudoRoot,\n      isLastChild = _ref21.isLastChild,\n      node = _ref21.node,\n      currentIndex = _ref21.currentIndex,\n      currentDepth = _ref21.currentDepth,\n      getNodeKey = _ref21.getNodeKey,\n      _ref21$path = _ref21.path,\n      path = _ref21$path === void 0 ? [] : _ref21$path;\n\n  var selfPath = function selfPath(n) {\n    return isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({\n      node: n,\n      treeIndex: currentIndex\n    })]);\n  }; // If the current position is the only possible place to add, add it\n\n\n  if (currentIndex >= minimumTreeIndex - 1 || isLastChild && !(node.children && node.children.length)) {\n    if (typeof node.children === \"function\") {\n      throw new Error(\"Cannot add to children defined by a function\");\n    } else {\n      var extraNodeProps = expandParent ? {\n        expanded: true\n      } : {};\n\n      var _nextNode = _objectSpread({}, node, extraNodeProps, {\n        children: node.children ? [newNode].concat(_toConsumableArray(node.children)) : [newNode]\n      });\n\n      return {\n        node: _nextNode,\n        nextIndex: currentIndex + 2,\n        insertedTreeIndex: currentIndex + 1,\n        parentPath: selfPath(_nextNode),\n        parentNode: isPseudoRoot ? null : _nextNode\n      };\n    }\n  } // If this is the target depth for the insertion,\n  // i.e., where the newNode can be added to the current node's children\n\n\n  if (currentDepth >= targetDepth - 1) {\n    // Skip over nodes with no children or hidden children\n    if (!node.children || typeof node.children === \"function\" || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n      return {\n        node: node,\n        nextIndex: currentIndex + 1\n      };\n    } // Scan over the children to see if there's a place among them that fulfills\n    // the minimumTreeIndex requirement\n\n\n    var _childIndex = currentIndex + 1;\n\n    var _insertedTreeIndex = null;\n    var insertIndex = null;\n\n    for (var i = 0; i < node.children.length; i += 1) {\n      // If a valid location is found, mark it as the insertion location and\n      // break out of the loop\n      if (_childIndex >= minimumTreeIndex) {\n        _insertedTreeIndex = _childIndex;\n        insertIndex = i;\n        break;\n      } // Increment the index by the child itself plus the number of descendants it has\n\n\n      _childIndex += 1 + getDescendantCount({\n        node: node.children[i],\n        ignoreCollapsed: ignoreCollapsed\n      });\n    } // If no valid indices to add the node were found\n\n\n    if (insertIndex === null) {\n      // If the last position in this node's children is less than the minimum index\n      // and there are more children on the level of this node, return without insertion\n      if (_childIndex < minimumTreeIndex && !isLastChild) {\n        return {\n          node: node,\n          nextIndex: _childIndex\n        };\n      } // Use the last position in the children array to insert the newNode\n\n\n      _insertedTreeIndex = _childIndex;\n      insertIndex = node.children.length;\n    } // Insert the newNode at the insertIndex\n\n\n    var _nextNode2 = _objectSpread({}, node, {\n      children: [].concat(_toConsumableArray(node.children.slice(0, insertIndex)), [newNode], _toConsumableArray(node.children.slice(insertIndex)))\n    }); // Return node with successful insert result\n\n\n    return {\n      node: _nextNode2,\n      nextIndex: _childIndex,\n      insertedTreeIndex: _insertedTreeIndex,\n      parentPath: selfPath(_nextNode2),\n      parentNode: isPseudoRoot ? null : _nextNode2\n    };\n  } // Skip over nodes with no children or hidden children\n\n\n  if (!node.children || typeof node.children === \"function\" || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return {\n      node: node,\n      nextIndex: currentIndex + 1\n    };\n  } // Get all descendants\n\n\n  var insertedTreeIndex = null;\n  var pathFragment = null;\n  var parentNode = null;\n  var childIndex = currentIndex + 1;\n  var newChildren = node.children;\n\n  if (typeof newChildren !== \"function\") {\n    newChildren = newChildren.map(function (child, i) {\n      if (insertedTreeIndex !== null) {\n        return child;\n      }\n\n      var mapResult = addNodeAtDepthAndIndex({\n        targetDepth: targetDepth,\n        minimumTreeIndex: minimumTreeIndex,\n        newNode: newNode,\n        ignoreCollapsed: ignoreCollapsed,\n        expandParent: expandParent,\n        isLastChild: isLastChild && i === newChildren.length - 1,\n        node: child,\n        currentIndex: childIndex,\n        currentDepth: currentDepth + 1,\n        getNodeKey: getNodeKey,\n        path: [] // Cannot determine the parent path until the children have been processed\n\n      });\n\n      if (\"insertedTreeIndex\" in mapResult) {\n        insertedTreeIndex = mapResult.insertedTreeIndex;\n        parentNode = mapResult.parentNode;\n        pathFragment = mapResult.parentPath;\n      }\n\n      childIndex = mapResult.nextIndex;\n      return mapResult.node;\n    });\n  }\n\n  var nextNode = _objectSpread({}, node, {\n    children: newChildren\n  });\n\n  var result = {\n    node: nextNode,\n    nextIndex: childIndex\n  };\n\n  if (insertedTreeIndex !== null) {\n    result.insertedTreeIndex = insertedTreeIndex;\n    result.parentPath = [].concat(_toConsumableArray(selfPath(nextNode)), _toConsumableArray(pathFragment));\n    result.parentNode = parentNode;\n  }\n\n  return result;\n}\n/**\n * Insert a node into the tree at the given depth, after the minimum index\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n * @param {!Object} newNode - The node to insert into the tree\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node added\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\n * @return {Object} result.parentNode - The parent node of the inserted node\n */\n\n\nexport function insertNode(_ref22) {\n  var treeData = _ref22.treeData,\n      targetDepth = _ref22.depth,\n      minimumTreeIndex = _ref22.minimumTreeIndex,\n      newNode = _ref22.newNode,\n      _ref22$getNodeKey = _ref22.getNodeKey,\n      getNodeKey = _ref22$getNodeKey === void 0 ? function () {} : _ref22$getNodeKey,\n      _ref22$ignoreCollapse = _ref22.ignoreCollapsed,\n      ignoreCollapsed = _ref22$ignoreCollapse === void 0 ? true : _ref22$ignoreCollapse,\n      _ref22$expandParent = _ref22.expandParent,\n      expandParent = _ref22$expandParent === void 0 ? false : _ref22$expandParent;\n\n  if (!treeData && targetDepth === 0) {\n    return {\n      treeData: [newNode],\n      treeIndex: 0,\n      path: [getNodeKey({\n        node: newNode,\n        treeIndex: 0\n      })],\n      parentNode: null\n    };\n  }\n\n  var insertResult = addNodeAtDepthAndIndex({\n    targetDepth: targetDepth,\n    minimumTreeIndex: minimumTreeIndex,\n    newNode: newNode,\n    ignoreCollapsed: ignoreCollapsed,\n    expandParent: expandParent,\n    getNodeKey: getNodeKey,\n    isPseudoRoot: true,\n    isLastChild: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    currentDepth: -1\n  });\n\n  if (!(\"insertedTreeIndex\" in insertResult)) {\n    throw new Error(\"No suitable position found to insert.\");\n  }\n\n  var treeIndex = insertResult.insertedTreeIndex;\n  return {\n    treeData: insertResult.node.children,\n    treeIndex: treeIndex,\n    path: [].concat(_toConsumableArray(insertResult.parentPath), [getNodeKey({\n      node: newNode,\n      treeIndex: treeIndex\n    })]),\n    parentNode: insertResult.parentNode\n  };\n}\n/**\n * Get tree data flattened.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }}[] nodes - The node array\n */\n\nif (typeof insertNode !== 'undefined' && insertNode && insertNode === Object(insertNode) && Object.isExtensible(insertNode)) {\n  Object.defineProperty(insertNode, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"insertNode\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nexport function getFlatDataFromTree(_ref23) {\n  var treeData = _ref23.treeData,\n      getNodeKey = _ref23.getNodeKey,\n      _ref23$ignoreCollapse = _ref23.ignoreCollapsed,\n      ignoreCollapsed = _ref23$ignoreCollapse === void 0 ? true : _ref23$ignoreCollapse;\n\n  if (!treeData || treeData.length < 1) {\n    return [];\n  }\n\n  var flattened = [];\n  walk({\n    treeData: treeData,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    callback: function callback(nodeInfo) {\n      flattened.push(nodeInfo);\n    }\n  });\n  return flattened;\n}\n/**\n * Generate a tree structure from flat data.\n *\n * @param {!Object[]} flatData\n * @param {!function=} getKey - Function to get the key from the nodeData\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\n *\n * @return {Object[]} treeData - The flat data represented as a tree\n */\n\nif (typeof getFlatDataFromTree !== 'undefined' && getFlatDataFromTree && getFlatDataFromTree === Object(getFlatDataFromTree) && Object.isExtensible(getFlatDataFromTree)) {\n  Object.defineProperty(getFlatDataFromTree, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"getFlatDataFromTree\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nexport function getTreeFromFlatData(_ref24) {\n  var flatData = _ref24.flatData,\n      _ref24$getKey = _ref24.getKey,\n      getKey = _ref24$getKey === void 0 ? function (node) {\n    return node.id;\n  } : _ref24$getKey,\n      _ref24$getParentKey = _ref24.getParentKey,\n      getParentKey = _ref24$getParentKey === void 0 ? function (node) {\n    return node.parentId;\n  } : _ref24$getParentKey,\n      _ref24$rootKey = _ref24.rootKey,\n      rootKey = _ref24$rootKey === void 0 ? \"0\" : _ref24$rootKey;\n\n  if (!flatData) {\n    return [];\n  }\n\n  var childrenToParents = {};\n  flatData.forEach(function (child) {\n    var parentKey = getParentKey(child);\n\n    if (parentKey in childrenToParents) {\n      childrenToParents[parentKey].push(child);\n    } else {\n      childrenToParents[parentKey] = [child];\n    }\n  });\n\n  if (!(rootKey in childrenToParents)) {\n    return [];\n  }\n\n  var trav = function trav(parent) {\n    var parentKey = getKey(parent);\n\n    if (parentKey in childrenToParents) {\n      return _objectSpread({}, parent, {\n        children: childrenToParents[parentKey].map(function (child) {\n          return trav(child);\n        })\n      });\n    }\n\n    return _objectSpread({}, parent);\n  };\n\n  return childrenToParents[rootKey].map(function (child) {\n    return trav(child);\n  });\n}\n/**\n * Check if a node is a descendant of another node.\n *\n * @param {!Object} older - Potential ancestor of younger node\n * @param {!Object} younger - Potential descendant of older node\n *\n * @return {boolean}\n */\n\nif (typeof getTreeFromFlatData !== 'undefined' && getTreeFromFlatData && getTreeFromFlatData === Object(getTreeFromFlatData) && Object.isExtensible(getTreeFromFlatData)) {\n  Object.defineProperty(getTreeFromFlatData, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"getTreeFromFlatData\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nexport function isDescendant(older, younger) {\n  return !!older.children && typeof older.children !== \"function\" && older.children.some(function (child) {\n    return child === younger || isDescendant(child, younger);\n  });\n}\n/**\n * Get the maximum depth of the children (the depth of the root node is 0).\n *\n * @param {!Object} node - Node in the tree\n * @param {?number} depth - The current depth\n *\n * @return {number} maxDepth - The deepest depth in the tree\n */\n\nif (typeof isDescendant !== 'undefined' && isDescendant && isDescendant === Object(isDescendant) && Object.isExtensible(isDescendant)) {\n  Object.defineProperty(isDescendant, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"isDescendant\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nexport function getDepth(node) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  if (!node.children) {\n    return depth;\n  }\n\n  if (typeof node.children === \"function\") {\n    return depth + 1;\n  }\n\n  return node.children.reduce(function (deepest, child) {\n    return Math.max(deepest, getDepth(child, depth + 1));\n  }, depth);\n}\n/**\n * Find nodes matching a search query in the tree,\n *\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {!Object[]} treeData - Tree data\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n * @param {?number} searchFocusOffset - The offset of the match to focus on\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n *\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n *                               it will be the same as the original tree data.\n */\n\nif (typeof getDepth !== 'undefined' && getDepth && getDepth === Object(getDepth) && Object.isExtensible(getDepth)) {\n  Object.defineProperty(getDepth, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"getDepth\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nexport function find(_ref25) {\n  var getNodeKey = _ref25.getNodeKey,\n      treeData = _ref25.treeData,\n      searchQuery = _ref25.searchQuery,\n      searchMethod = _ref25.searchMethod,\n      searchFocusOffset = _ref25.searchFocusOffset,\n      _ref25$expandAllMatch = _ref25.expandAllMatchPaths,\n      expandAllMatchPaths = _ref25$expandAllMatch === void 0 ? false : _ref25$expandAllMatch,\n      _ref25$expandFocusMat = _ref25.expandFocusMatchPaths,\n      expandFocusMatchPaths = _ref25$expandFocusMat === void 0 ? true : _ref25$expandFocusMat;\n  var matchCount = 0;\n\n  var trav = function trav(_ref26) {\n    var _ref26$isPseudoRoot = _ref26.isPseudoRoot,\n        isPseudoRoot = _ref26$isPseudoRoot === void 0 ? false : _ref26$isPseudoRoot,\n        node = _ref26.node,\n        currentIndex = _ref26.currentIndex,\n        _ref26$path = _ref26.path,\n        path = _ref26$path === void 0 ? [] : _ref26$path;\n    var matches = [];\n    var isSelfMatch = false;\n    var hasFocusMatch = false; // The pseudo-root is not considered in the path\n\n    var selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({\n      node: node,\n      treeIndex: currentIndex\n    })]);\n    var extraInfo = isPseudoRoot ? null : {\n      path: selfPath,\n      treeIndex: currentIndex\n    }; // Nodes with with children that aren't lazy\n\n    var hasChildren = node.children && typeof node.children !== \"function\" && node.children.length > 0; // Examine the current node to see if it is a match\n\n    if (!isPseudoRoot && searchMethod(_objectSpread({}, extraInfo, {\n      node: node,\n      searchQuery: searchQuery\n    }))) {\n      if (matchCount === searchFocusOffset) {\n        hasFocusMatch = true;\n      } // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n      //  is reached\n\n\n      matchCount += 1; // We cannot add this node to the matches right away, as it may be changed\n      //  during the search of the descendants. The entire node is used in\n      //  comparisons between nodes inside the `matches` and `treeData` results\n      //  of this method (`find`)\n\n      isSelfMatch = true;\n    }\n\n    var childIndex = currentIndex;\n\n    var newNode = _objectSpread({}, node);\n\n    if (hasChildren) {\n      // Get all descendants\n      newNode.children = newNode.children.map(function (child) {\n        var mapResult = trav({\n          node: child,\n          currentIndex: childIndex + 1,\n          path: selfPath\n        }); // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n        // if the child is expanded.\n        //\n        // The child could have been expanded from the start,\n        // or expanded due to a matching node being found in its descendants\n\n        if (mapResult.node.expanded) {\n          childIndex = mapResult.treeIndex;\n        } else {\n          childIndex += 1;\n        }\n\n        if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n          matches = [].concat(_toConsumableArray(matches), _toConsumableArray(mapResult.matches));\n\n          if (mapResult.hasFocusMatch) {\n            hasFocusMatch = true;\n          } // Expand the current node if it has descendants matching the search\n          // and the settings are set to do so.\n\n\n          if (expandAllMatchPaths && mapResult.matches.length > 0 || (expandAllMatchPaths || expandFocusMatchPaths) && mapResult.hasFocusMatch) {\n            newNode.expanded = true;\n          }\n        }\n\n        return mapResult.node;\n      });\n    } // Cannot assign a treeIndex to hidden nodes\n\n\n    if (!isPseudoRoot && !newNode.expanded) {\n      matches = matches.map(function (match) {\n        return _objectSpread({}, match, {\n          treeIndex: null\n        });\n      });\n    } // Add this node to the matches if it fits the search criteria.\n    // This is performed at the last minute so newNode can be sent in its final form.\n\n\n    if (isSelfMatch) {\n      matches = [_objectSpread({}, extraInfo, {\n        node: newNode\n      })].concat(_toConsumableArray(matches));\n    }\n\n    return {\n      node: matches.length > 0 ? newNode : node,\n      matches: matches,\n      hasFocusMatch: hasFocusMatch,\n      treeIndex: childIndex\n    };\n  };\n\n  var result = trav({\n    node: {\n      children: treeData\n    },\n    isPseudoRoot: true,\n    currentIndex: -1\n  });\n  return {\n    matches: result.matches,\n    treeData: result.node.children\n  };\n}\n\nif (typeof find !== 'undefined' && find && find === Object(find) && Object.isExtensible(find)) {\n  Object.defineProperty(find, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"find\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nexport function treeToList(arr) {\n  var treeList = arr || []; //末级节点\n\n  var leafs = []; //根\n\n  var roots = []; //所有节点\n\n  var list = [];\n\n  for (var i = 0; i < treeList.length; i++) {\n    var d = treeList[i];\n\n    if (!d) {\n      continue;\n    }\n\n    var childrens = d.children || [];\n    d.__depth = 0;\n    list.push(d);\n    roots.push(d);\n\n    if (childrens.length > 0) {\n      getChildren(d, 0);\n    } else {\n      leafs.push(d);\n    }\n  }\n\n  function getChildren(d, depth) {\n    var tempArr = d.children || [];\n\n    for (var _i = 0; _i < tempArr.length; _i++) {\n      var _d = tempArr[_i];\n\n      var _childrens = _d.children || [];\n\n      _d.__depth = depth + 1;\n      list.push(_d);\n\n      if (_childrens.length > 0) {\n        getChildren(_d, depth + 1);\n      } else {\n        leafs.push(_d);\n      }\n    }\n  }\n\n  return {\n    list: list,\n    leafs: leafs,\n    roots: roots\n  };\n}\n\nif (typeof treeToList !== 'undefined' && treeToList && treeToList === Object(treeToList) && Object.isExtensible(treeToList)) {\n  Object.defineProperty(treeToList, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"treeToList\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\nexport function getDataListWithExpanded(list) {\n  var expandedKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var rowKey = arguments.length > 2 ? arguments[2] : undefined;\n  var arr = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var d = list[i];\n    d.__depth = 0;\n    arr.push(d);\n\n    if (expandedKeys.indexOf(d[rowKey]) > -1) {\n      if (d.children) {\n        setChildren(d, 0);\n      }\n    }\n  }\n\n  function setChildren(c, depth) {\n    var cArr = c.children;\n\n    for (var _i2 = 0; _i2 < cArr.length; _i2++) {\n      var _d2 = cArr[_i2];\n      _d2.__depth = depth + 1;\n      arr.push(_d2);\n\n      if (expandedKeys.indexOf(_d2[rowKey]) > -1) {\n        if (_d2.children) {\n          setChildren(_d2, depth + 1);\n        }\n      }\n    }\n  }\n\n  return arr;\n}\n\nif (typeof getDataListWithExpanded !== 'undefined' && getDataListWithExpanded && getDataListWithExpanded === Object(getDataListWithExpanded) && Object.isExtensible(getDataListWithExpanded)) {\n  Object.defineProperty(getDataListWithExpanded, '__filemeta', {\n    enumerable: true,\n    configurable: true,\n    value: {\n      name: \"getDataListWithExpanded\",\n      filename: \"src/tree-data-utils.js\"\n    }\n  });\n}\n\n;\n\n(function () {\n  var reactHotLoader = (typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal : require('react-hot-loader')).default;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(getNodeDataAtTreeIndexOrNextIndex, \"getNodeDataAtTreeIndexOrNextIndex\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(getDescendantCount, \"getDescendantCount\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(walkDescendants, \"walkDescendants\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(mapDescendants, \"mapDescendants\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(getVisibleNodeCount, \"getVisibleNodeCount\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(getVisibleNodeInfoAtIndex, \"getVisibleNodeInfoAtIndex\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(walk, \"walk\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(map, \"map\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(toggleExpandedForAll, \"toggleExpandedForAll\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(changeNodeAtPath, \"changeNodeAtPath\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(removeNodeAtPath, \"removeNodeAtPath\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(removeNode, \"removeNode\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(getNodeAtPath, \"getNodeAtPath\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(addNodeUnderParent, \"addNodeUnderParent\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(addNodeAtDepthAndIndex, \"addNodeAtDepthAndIndex\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(insertNode, \"insertNode\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(getFlatDataFromTree, \"getFlatDataFromTree\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(getTreeFromFlatData, \"getTreeFromFlatData\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(isDescendant, \"isDescendant\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(getDepth, \"getDepth\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(find, \"find\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(treeToList, \"treeToList\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n  reactHotLoader.register(getDataListWithExpanded, \"getDataListWithExpanded\", \"/home/nexx/develop/tablex/src/tree-data-utils.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = (typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal : require('react-hot-loader')).leaveModule;\n  leaveModule && leaveModule(module);\n})();",{"version":3,"sources":["/home/nexx/develop/tablex/src/tree-data-utils.js"],"names":["getNodeDataAtTreeIndexOrNextIndex","targetIndex","node","currentIndex","getNodeKey","path","lowerSiblingCounts","ignoreCollapsed","isPseudoRoot","selfPath","treeIndex","children","expanded","nextIndex","childIndex","childCount","length","i","result","getDescendantCount","walkDescendants","callback","parentNode","selfInfo","callbackResult","mapDescendants","nextNode","map","child","mapResult","getVisibleNodeCount","treeData","traverse","reduce","total","currentNode","getVisibleNodeInfoAtIndex","index","walk","toggleExpandedForAll","changeNodeAtPath","newNode","RESULT_MISS","currentTreeIndex","pathIndex","Error","nextTreeIndex","slice","removeNodeAtPath","removeNode","removedNode","removedTreeIndex","nextTreeData","getNodeAtPath","foundNodeInfo","err","addNodeUnderParent","parentKey","expandParent","addAsFirstChild","insertedTreeIndex","hasBeenAdded","changedTreeData","key","addNodeAtDepthAndIndex","targetDepth","minimumTreeIndex","isLastChild","currentDepth","n","extraNodeProps","parentPath","insertIndex","pathFragment","newChildren","insertNode","depth","insertResult","getFlatDataFromTree","flattened","nodeInfo","push","getTreeFromFlatData","flatData","getKey","id","getParentKey","parentId","rootKey","childrenToParents","forEach","trav","parent","isDescendant","older","younger","some","getDepth","deepest","Math","max","find","searchQuery","searchMethod","searchFocusOffset","expandAllMatchPaths","expandFocusMatchPaths","matchCount","matches","isSelfMatch","hasFocusMatch","extraInfo","hasChildren","match","treeToList","arr","treeList","leafs","roots","list","d","childrens","__depth","getChildren","tempArr","getDataListWithExpanded","expandedKeys","rowKey","indexOf","setChildren","c","cArr"],"mappings":"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","sourcesContent":["/**\n * Performs a depth-first traversal over all of the node descendants,\n * incrementing currentIndex by 1 for each\n */\nfunction getNodeDataAtTreeIndexOrNextIndex({\n  targetIndex,\n  node,\n  currentIndex,\n  getNodeKey,\n  path = [],\n  lowerSiblingCounts = [],\n  ignoreCollapsed = true,\n  isPseudoRoot = false\n}) {\n  // The pseudo-root is not considered in the path\n  const selfPath = !isPseudoRoot\n    ? [...path, getNodeKey({ node, treeIndex: currentIndex })]\n    : [];\n\n  // Return target node when found\n  if (currentIndex === targetIndex) {\n    return {\n      node,\n      lowerSiblingCounts,\n      path: selfPath\n    };\n  }\n\n  // Add one and continue for nodes with no children or hidden children\n  if (!node.children || (ignoreCollapsed && node.expanded !== true)) {\n    return { nextIndex: currentIndex + 1 };\n  }\n\n  // Iterate over each child and their descendants and return the\n  // target node if childIndex reaches the targetIndex\n  let childIndex = currentIndex + 1;\n  const childCount = node.children.length;\n  for (let i = 0; i < childCount; i += 1) {\n    const result = getNodeDataAtTreeIndexOrNextIndex({\n      ignoreCollapsed,\n      getNodeKey,\n      targetIndex,\n      node: node.children[i],\n      currentIndex: childIndex,\n      lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n      path: selfPath\n    });\n\n    if (result.node) {\n      return result;\n    }\n\n    childIndex = result.nextIndex;\n  }\n\n  // If the target node is not found, return the farthest traversed index\n  return { nextIndex: childIndex };\n}\n\nexport function getDescendantCount({ node, ignoreCollapsed = true }) {\n  return (\n    getNodeDataAtTreeIndexOrNextIndex({\n      getNodeKey: () => {},\n      ignoreCollapsed,\n      node,\n      currentIndex: 0,\n      targetIndex: -1\n    }).nextIndex - 1\n  );\n}\n\n/**\n * Walk all descendants of the given node, depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\nfunction walkDescendants({\n  callback,\n  getNodeKey,\n  ignoreCollapsed,\n  isPseudoRoot = false,\n  node,\n  parentNode = null,\n  currentIndex,\n  path = [],\n  lowerSiblingCounts = []\n}) {\n  // The pseudo-root is not considered in the path\n  const selfPath = isPseudoRoot\n    ? []\n    : [...path, getNodeKey({ node, treeIndex: currentIndex })];\n  const selfInfo = isPseudoRoot\n    ? null\n    : {\n        node,\n        parentNode,\n        path: selfPath,\n        lowerSiblingCounts,\n        treeIndex: currentIndex\n      };\n\n  if (!isPseudoRoot) {\n    const callbackResult = callback(selfInfo);\n\n    // Cut walk short if the callback returned false\n    if (callbackResult === false) {\n      return false;\n    }\n  }\n\n  // Return self on nodes with no children or hidden children\n  if (\n    !node.children ||\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return currentIndex;\n  }\n\n  // Get all descendants\n  let childIndex = currentIndex;\n  const childCount = node.children.length;\n  if (typeof node.children !== \"function\") {\n    for (let i = 0; i < childCount; i += 1) {\n      childIndex = walkDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        node: node.children[i],\n        parentNode: isPseudoRoot ? null : node,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n        path: selfPath\n      });\n\n      // Cut walk short if the callback returned false\n      if (childIndex === false) {\n        return false;\n      }\n    }\n  }\n\n  return childIndex;\n}\n\n/**\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\nfunction mapDescendants({\n  callback,\n  getNodeKey,\n  ignoreCollapsed,\n  isPseudoRoot = false,\n  node,\n  parentNode = null,\n  currentIndex,\n  path = [],\n  lowerSiblingCounts = []\n}) {\n  const nextNode = { ...node };\n\n  // The pseudo-root is not considered in the path\n  const selfPath = isPseudoRoot\n    ? []\n    : [...path, getNodeKey({ node: nextNode, treeIndex: currentIndex })];\n  const selfInfo = {\n    node: nextNode,\n    parentNode,\n    path: selfPath,\n    lowerSiblingCounts,\n    treeIndex: currentIndex\n  };\n\n  // Return self on nodes with no children or hidden children\n  if (\n    !nextNode.children ||\n    (nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return {\n      treeIndex: currentIndex,\n      node: callback(selfInfo)\n    };\n  }\n\n  // Get all descendants\n  let childIndex = currentIndex;\n  const childCount = nextNode.children.length;\n  if (typeof nextNode.children !== \"function\") {\n    nextNode.children = nextNode.children.map((child, i) => {\n      const mapResult = mapDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        node: child,\n        parentNode: isPseudoRoot ? null : nextNode,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n        path: selfPath\n      });\n      childIndex = mapResult.treeIndex;\n\n      return mapResult.node;\n    });\n  }\n\n  return {\n    node: callback(selfInfo),\n    treeIndex: childIndex\n  };\n}\n\n/**\n * Count all the visible (expanded) descendants in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n *\n * @return {number} count\n */\nexport function getVisibleNodeCount({ treeData }) {\n  const traverse = node => {\n    if (\n      !node.children ||\n      node.expanded !== true ||\n      typeof node.children === \"function\"\n    ) {\n      return 1;\n    }\n\n    return (\n      1 +\n      node.children.reduce(\n        (total, currentNode) => total + traverse(currentNode),\n        0\n      )\n    );\n  };\n\n  return treeData.reduce(\n    (total, currentNode) => total + traverse(currentNode),\n    0\n  );\n}\n\n/**\n * Get the <targetIndex>th visible node in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} targetIndex - The index of the node to search for\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }|null} node - The node at targetIndex, or null if not found\n */\nexport function getVisibleNodeInfoAtIndex({\n  treeData,\n  index: targetIndex,\n  getNodeKey\n}) {\n  if (!treeData || treeData.length < 1) {\n    return null;\n  }\n\n  // Call the tree traversal with a pseudo-root node\n  const result = getNodeDataAtTreeIndexOrNextIndex({\n    targetIndex,\n    getNodeKey,\n    node: {\n      children: treeData,\n      expanded: true\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: [],\n    isPseudoRoot: true\n  });\n\n  if (result.node) {\n    return result;\n  }\n\n  return null;\n}\n\n/**\n * Walk descendants depth-first and call a callback on each\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return void\n */\nexport function walk({\n  treeData,\n  getNodeKey,\n  callback,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return;\n  }\n\n  walkDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  });\n}\n\n/**\n * Perform a depth-first transversal of the descendants and\n *  make a change to every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function map({\n  treeData,\n  getNodeKey,\n  callback,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return [];\n  }\n\n  return mapDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  }).node.children;\n}\n\n/**\n * Expand or close every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {?boolean} expanded - Whether the node is expanded or not\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function toggleExpandedForAll({ treeData, expanded = true }) {\n  return map({\n    treeData,\n    callback: ({ node }) => ({ ...node, expanded }),\n    getNodeKey: ({ treeIndex }) => treeIndex,\n    ignoreCollapsed: false\n  });\n}\n\n/**\n * Replaces node at path with object, or callback-defined object\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function changeNodeAtPath({\n  treeData,\n  path,\n  newNode,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  const RESULT_MISS = \"RESULT_MISS\";\n  const traverse = ({\n    isPseudoRoot = false,\n    node,\n    currentTreeIndex,\n    pathIndex\n  }) => {\n    if (\n      !isPseudoRoot &&\n      getNodeKey({ node, treeIndex: currentTreeIndex }) !== path[pathIndex]\n    ) {\n      return RESULT_MISS;\n    }\n\n    if (pathIndex >= path.length - 1) {\n      // If this is the final location in the path, return its changed form\n      return typeof newNode === \"function\"\n        ? newNode({ node, treeIndex: currentTreeIndex })\n        : newNode;\n    }\n    if (!node.children) {\n      // If this node is part of the path, but has no children, return the unchanged node\n      throw new Error(\"Path referenced children of node with no children.\");\n    }\n\n    let nextTreeIndex = currentTreeIndex + 1;\n    for (let i = 0; i < node.children.length; i += 1) {\n      const result = traverse({\n        node: node.children[i],\n        currentTreeIndex: nextTreeIndex,\n        pathIndex: pathIndex + 1\n      });\n\n      // If the result went down the correct path\n      if (result !== RESULT_MISS) {\n        if (result) {\n          // If the result was truthy (in this case, an object),\n          //  pass it to the next level of recursion up\n          return {\n            ...node,\n            children: [\n              ...node.children.slice(0, i),\n              result,\n              ...node.children.slice(i + 1)\n            ]\n          };\n        }\n        // If the result was falsy (returned from the newNode function), then\n        //  delete the node from the array.\n        return {\n          ...node,\n          children: [\n            ...node.children.slice(0, i),\n            ...node.children.slice(i + 1)\n          ]\n        };\n      }\n\n      nextTreeIndex +=\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\n    }\n\n    return RESULT_MISS;\n  };\n\n  // Use a pseudo-root node in the beginning traversal\n  const result = traverse({\n    node: { children: treeData },\n    currentTreeIndex: -1,\n    pathIndex: -1,\n    isPseudoRoot: true\n  });\n\n  if (result === RESULT_MISS) {\n    throw new Error(\"No node found at the given path.\");\n  }\n\n  return result.children;\n}\n\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The tree data with the node removed\n */\nexport function removeNodeAtPath({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  return changeNodeAtPath({\n    treeData,\n    path,\n    getNodeKey,\n    ignoreCollapsed,\n    newNode: null // Delete the node\n  });\n}\n\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node removed\n * @return {Object} result.node - The node that was removed\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\n */\nexport function removeNode({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  let removedNode = null;\n  let removedTreeIndex = null;\n  const nextTreeData = changeNodeAtPath({\n    treeData,\n    path,\n    getNodeKey,\n    ignoreCollapsed,\n    newNode: ({ node, treeIndex }) => {\n      // Store the target node and delete it from the tree\n      removedNode = node;\n      removedTreeIndex = treeIndex;\n\n      return null;\n    }\n  });\n\n  return {\n    treeData: nextTreeData,\n    node: removedNode,\n    treeIndex: removedTreeIndex\n  };\n}\n\n/**\n * Gets the node at the specified path\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n */\nexport function getNodeAtPath({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  let foundNodeInfo = null;\n\n  try {\n    changeNodeAtPath({\n      treeData,\n      path,\n      getNodeKey,\n      ignoreCollapsed,\n      newNode: ({ node, treeIndex }) => {\n        foundNodeInfo = { node, treeIndex };\n        return node;\n      }\n    });\n  } catch (err) {\n    // Ignore the error -- the null return will be explanation enough\n  }\n\n  return foundNodeInfo;\n}\n\n/**\n * Adds the node to the specified parent and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {!Object} newNode - The node to insert\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The updated tree data\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n */\nexport function addNodeUnderParent({\n  treeData,\n  newNode,\n  parentKey = null,\n  getNodeKey,\n  ignoreCollapsed = true,\n  expandParent = false,\n  addAsFirstChild = false\n}) {\n  if (parentKey === null) {\n    return {\n      treeData: [...(treeData || []), newNode],\n      treeIndex: (treeData || []).length\n    };\n  }\n\n  let insertedTreeIndex = null;\n  let hasBeenAdded = false;\n  const changedTreeData = map({\n    treeData,\n    getNodeKey,\n    ignoreCollapsed,\n    callback: ({ node, treeIndex, path }) => {\n      const key = path ? path[path.length - 1] : null;\n      // Return nodes that are not the parent as-is\n      if (hasBeenAdded || key !== parentKey) {\n        return node;\n      }\n      hasBeenAdded = true;\n\n      const parentNode = {\n        ...node\n      };\n\n      if (expandParent) {\n        parentNode.expanded = true;\n      }\n\n      // If no children exist yet, just add the single newNode\n      if (!parentNode.children) {\n        insertedTreeIndex = treeIndex + 1;\n        return {\n          ...parentNode,\n          children: [newNode]\n        };\n      }\n\n      if (typeof parentNode.children === \"function\") {\n        throw new Error(\"Cannot add to children defined by a function\");\n      }\n\n      let nextTreeIndex = treeIndex + 1;\n      for (let i = 0; i < parentNode.children.length; i += 1) {\n        nextTreeIndex +=\n          1 +\n          getDescendantCount({ node: parentNode.children[i], ignoreCollapsed });\n      }\n\n      insertedTreeIndex = nextTreeIndex;\n\n      const children = addAsFirstChild\n        ? [newNode, ...parentNode.children]\n        : [...parentNode.children, newNode];\n\n      return {\n        ...parentNode,\n        children\n      };\n    }\n  });\n\n  if (!hasBeenAdded) {\n    throw new Error(\"No node found with the given key.\");\n  }\n\n  return {\n    treeData: changedTreeData,\n    treeIndex: insertedTreeIndex\n  };\n}\n\nfunction addNodeAtDepthAndIndex({\n  targetDepth,\n  minimumTreeIndex,\n  newNode,\n  ignoreCollapsed,\n  expandParent,\n  isPseudoRoot = false,\n  isLastChild,\n  node,\n  currentIndex,\n  currentDepth,\n  getNodeKey,\n  path = []\n}) {\n  const selfPath = n =>\n    isPseudoRoot\n      ? []\n      : [...path, getNodeKey({ node: n, treeIndex: currentIndex })];\n\n  // If the current position is the only possible place to add, add it\n  if (\n    currentIndex >= minimumTreeIndex - 1 ||\n    (isLastChild && !(node.children && node.children.length))\n  ) {\n    if (typeof node.children === \"function\") {\n      throw new Error(\"Cannot add to children defined by a function\");\n    } else {\n      const extraNodeProps = expandParent ? { expanded: true } : {};\n      const nextNode = {\n        ...node,\n\n        ...extraNodeProps,\n        children: node.children ? [newNode, ...node.children] : [newNode]\n      };\n\n      return {\n        node: nextNode,\n        nextIndex: currentIndex + 2,\n        insertedTreeIndex: currentIndex + 1,\n        parentPath: selfPath(nextNode),\n        parentNode: isPseudoRoot ? null : nextNode\n      };\n    }\n  }\n\n  // If this is the target depth for the insertion,\n  // i.e., where the newNode can be added to the current node's children\n  if (currentDepth >= targetDepth - 1) {\n    // Skip over nodes with no children or hidden children\n    if (\n      !node.children ||\n      typeof node.children === \"function\" ||\n      (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n    ) {\n      return { node, nextIndex: currentIndex + 1 };\n    }\n\n    // Scan over the children to see if there's a place among them that fulfills\n    // the minimumTreeIndex requirement\n    let childIndex = currentIndex + 1;\n    let insertedTreeIndex = null;\n    let insertIndex = null;\n    for (let i = 0; i < node.children.length; i += 1) {\n      // If a valid location is found, mark it as the insertion location and\n      // break out of the loop\n      if (childIndex >= minimumTreeIndex) {\n        insertedTreeIndex = childIndex;\n        insertIndex = i;\n        break;\n      }\n\n      // Increment the index by the child itself plus the number of descendants it has\n      childIndex +=\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\n    }\n\n    // If no valid indices to add the node were found\n    if (insertIndex === null) {\n      // If the last position in this node's children is less than the minimum index\n      // and there are more children on the level of this node, return without insertion\n      if (childIndex < minimumTreeIndex && !isLastChild) {\n        return { node, nextIndex: childIndex };\n      }\n\n      // Use the last position in the children array to insert the newNode\n      insertedTreeIndex = childIndex;\n      insertIndex = node.children.length;\n    }\n\n    // Insert the newNode at the insertIndex\n    const nextNode = {\n      ...node,\n      children: [\n        ...node.children.slice(0, insertIndex),\n        newNode,\n        ...node.children.slice(insertIndex)\n      ]\n    };\n\n    // Return node with successful insert result\n    return {\n      node: nextNode,\n      nextIndex: childIndex,\n      insertedTreeIndex,\n      parentPath: selfPath(nextNode),\n      parentNode: isPseudoRoot ? null : nextNode\n    };\n  }\n\n  // Skip over nodes with no children or hidden children\n  if (\n    !node.children ||\n    typeof node.children === \"function\" ||\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return { node, nextIndex: currentIndex + 1 };\n  }\n\n  // Get all descendants\n  let insertedTreeIndex = null;\n  let pathFragment = null;\n  let parentNode = null;\n  let childIndex = currentIndex + 1;\n  let newChildren = node.children;\n  if (typeof newChildren !== \"function\") {\n    newChildren = newChildren.map((child, i) => {\n      if (insertedTreeIndex !== null) {\n        return child;\n      }\n\n      const mapResult = addNodeAtDepthAndIndex({\n        targetDepth,\n        minimumTreeIndex,\n        newNode,\n        ignoreCollapsed,\n        expandParent,\n        isLastChild: isLastChild && i === newChildren.length - 1,\n        node: child,\n        currentIndex: childIndex,\n        currentDepth: currentDepth + 1,\n        getNodeKey,\n        path: [] // Cannot determine the parent path until the children have been processed\n      });\n\n      if (\"insertedTreeIndex\" in mapResult) {\n        ({\n          insertedTreeIndex,\n          parentNode,\n          parentPath: pathFragment\n        } = mapResult);\n      }\n\n      childIndex = mapResult.nextIndex;\n\n      return mapResult.node;\n    });\n  }\n\n  const nextNode = { ...node, children: newChildren };\n  const result = {\n    node: nextNode,\n    nextIndex: childIndex\n  };\n\n  if (insertedTreeIndex !== null) {\n    result.insertedTreeIndex = insertedTreeIndex;\n    result.parentPath = [...selfPath(nextNode), ...pathFragment];\n    result.parentNode = parentNode;\n  }\n\n  return result;\n}\n\n/**\n * Insert a node into the tree at the given depth, after the minimum index\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n * @param {!Object} newNode - The node to insert into the tree\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node added\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\n * @return {Object} result.parentNode - The parent node of the inserted node\n */\nexport function insertNode({\n  treeData,\n  depth: targetDepth,\n  minimumTreeIndex,\n  newNode,\n  getNodeKey = () => {},\n  ignoreCollapsed = true,\n  expandParent = false\n}) {\n  if (!treeData && targetDepth === 0) {\n    return {\n      treeData: [newNode],\n      treeIndex: 0,\n      path: [getNodeKey({ node: newNode, treeIndex: 0 })],\n      parentNode: null\n    };\n  }\n\n  const insertResult = addNodeAtDepthAndIndex({\n    targetDepth,\n    minimumTreeIndex,\n    newNode,\n    ignoreCollapsed,\n    expandParent,\n    getNodeKey,\n    isPseudoRoot: true,\n    isLastChild: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    currentDepth: -1\n  });\n\n  if (!(\"insertedTreeIndex\" in insertResult)) {\n    throw new Error(\"No suitable position found to insert.\");\n  }\n\n  const treeIndex = insertResult.insertedTreeIndex;\n  return {\n    treeData: insertResult.node.children,\n    treeIndex,\n    path: [\n      ...insertResult.parentPath,\n      getNodeKey({ node: newNode, treeIndex })\n    ],\n    parentNode: insertResult.parentNode\n  };\n}\n\n/**\n * Get tree data flattened.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }}[] nodes - The node array\n */\nexport function getFlatDataFromTree({\n  treeData,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return [];\n  }\n\n  const flattened = [];\n  walk({\n    treeData,\n    getNodeKey,\n    ignoreCollapsed,\n    callback: nodeInfo => {\n      flattened.push(nodeInfo);\n    }\n  });\n\n  return flattened;\n}\n\n/**\n * Generate a tree structure from flat data.\n *\n * @param {!Object[]} flatData\n * @param {!function=} getKey - Function to get the key from the nodeData\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\n *\n * @return {Object[]} treeData - The flat data represented as a tree\n */\nexport function getTreeFromFlatData({\n  flatData,\n  getKey = node => node.id,\n  getParentKey = node => node.parentId,\n  rootKey = \"0\"\n}) {\n  if (!flatData) {\n    return [];\n  }\n\n  const childrenToParents = {};\n  flatData.forEach(child => {\n    const parentKey = getParentKey(child);\n\n    if (parentKey in childrenToParents) {\n      childrenToParents[parentKey].push(child);\n    } else {\n      childrenToParents[parentKey] = [child];\n    }\n  });\n\n  if (!(rootKey in childrenToParents)) {\n    return [];\n  }\n\n  const trav = parent => {\n    const parentKey = getKey(parent);\n    if (parentKey in childrenToParents) {\n      return {\n        ...parent,\n        children: childrenToParents[parentKey].map(child => trav(child))\n      };\n    }\n\n    return { ...parent };\n  };\n\n  return childrenToParents[rootKey].map(child => trav(child));\n}\n\n/**\n * Check if a node is a descendant of another node.\n *\n * @param {!Object} older - Potential ancestor of younger node\n * @param {!Object} younger - Potential descendant of older node\n *\n * @return {boolean}\n */\nexport function isDescendant(older, younger) {\n  return (\n    !!older.children &&\n    typeof older.children !== \"function\" &&\n    older.children.some(\n      child => child === younger || isDescendant(child, younger)\n    )\n  );\n}\n\n/**\n * Get the maximum depth of the children (the depth of the root node is 0).\n *\n * @param {!Object} node - Node in the tree\n * @param {?number} depth - The current depth\n *\n * @return {number} maxDepth - The deepest depth in the tree\n */\nexport function getDepth(node, depth = 0) {\n  if (!node.children) {\n    return depth;\n  }\n\n  if (typeof node.children === \"function\") {\n    return depth + 1;\n  }\n\n  return node.children.reduce(\n    (deepest, child) => Math.max(deepest, getDepth(child, depth + 1)),\n    depth\n  );\n}\n\n/**\n * Find nodes matching a search query in the tree,\n *\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {!Object[]} treeData - Tree data\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n * @param {?number} searchFocusOffset - The offset of the match to focus on\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n *\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n *                               it will be the same as the original tree data.\n */\nexport function find({\n  getNodeKey,\n  treeData,\n  searchQuery,\n  searchMethod,\n  searchFocusOffset,\n  expandAllMatchPaths = false,\n  expandFocusMatchPaths = true\n}) {\n  let matchCount = 0;\n  const trav = ({ isPseudoRoot = false, node, currentIndex, path = [] }) => {\n    let matches = [];\n    let isSelfMatch = false;\n    let hasFocusMatch = false;\n    // The pseudo-root is not considered in the path\n    const selfPath = isPseudoRoot\n      ? []\n      : [...path, getNodeKey({ node, treeIndex: currentIndex })];\n    const extraInfo = isPseudoRoot\n      ? null\n      : {\n          path: selfPath,\n          treeIndex: currentIndex\n        };\n\n    // Nodes with with children that aren't lazy\n    const hasChildren =\n      node.children &&\n      typeof node.children !== \"function\" &&\n      node.children.length > 0;\n\n    // Examine the current node to see if it is a match\n    if (!isPseudoRoot && searchMethod({ ...extraInfo, node, searchQuery })) {\n      if (matchCount === searchFocusOffset) {\n        hasFocusMatch = true;\n      }\n\n      // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n      //  is reached\n      matchCount += 1;\n\n      // We cannot add this node to the matches right away, as it may be changed\n      //  during the search of the descendants. The entire node is used in\n      //  comparisons between nodes inside the `matches` and `treeData` results\n      //  of this method (`find`)\n      isSelfMatch = true;\n    }\n\n    let childIndex = currentIndex;\n    const newNode = { ...node };\n    if (hasChildren) {\n      // Get all descendants\n      newNode.children = newNode.children.map(child => {\n        const mapResult = trav({\n          node: child,\n          currentIndex: childIndex + 1,\n          path: selfPath\n        });\n\n        // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n        // if the child is expanded.\n        //\n        // The child could have been expanded from the start,\n        // or expanded due to a matching node being found in its descendants\n        if (mapResult.node.expanded) {\n          childIndex = mapResult.treeIndex;\n        } else {\n          childIndex += 1;\n        }\n\n        if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n          matches = [...matches, ...mapResult.matches];\n          if (mapResult.hasFocusMatch) {\n            hasFocusMatch = true;\n          }\n\n          // Expand the current node if it has descendants matching the search\n          // and the settings are set to do so.\n          if (\n            (expandAllMatchPaths && mapResult.matches.length > 0) ||\n            ((expandAllMatchPaths || expandFocusMatchPaths) &&\n              mapResult.hasFocusMatch)\n          ) {\n            newNode.expanded = true;\n          }\n        }\n\n        return mapResult.node;\n      });\n    }\n\n    // Cannot assign a treeIndex to hidden nodes\n    if (!isPseudoRoot && !newNode.expanded) {\n      matches = matches.map(match => ({\n        ...match,\n        treeIndex: null\n      }));\n    }\n\n    // Add this node to the matches if it fits the search criteria.\n    // This is performed at the last minute so newNode can be sent in its final form.\n    if (isSelfMatch) {\n      matches = [{ ...extraInfo, node: newNode }, ...matches];\n    }\n\n    return {\n      node: matches.length > 0 ? newNode : node,\n      matches,\n      hasFocusMatch,\n      treeIndex: childIndex\n    };\n  };\n\n  const result = trav({\n    node: { children: treeData },\n    isPseudoRoot: true,\n    currentIndex: -1\n  });\n\n  return {\n    matches: result.matches,\n    treeData: result.node.children\n  };\n}\n\nexport function treeToList(arr) {\n  let treeList = arr || [];\n\n  //末级节点\n  let leafs = [];\n\n  //根\n  let roots = [];\n\n  //所有节点\n  let list = [];\n\n  for (let i = 0; i < treeList.length; i++) {\n    const d = treeList[i];\n\n    if (!d) {\n      continue;\n    }\n\n    const childrens = d.children || [];\n\n    d.__depth = 0;\n\n    list.push(d);\n    roots.push(d);\n\n    if (childrens.length > 0) {\n      getChildren(d, 0);\n    } else {\n      leafs.push(d);\n    }\n  }\n\n  function getChildren(d, depth) {\n    const tempArr = d.children || [];\n\n    for (let i = 0; i < tempArr.length; i++) {\n      const d = tempArr[i];\n      const childrens = d.children || [];\n\n      d.__depth = depth + 1;\n\n      list.push(d);\n\n      if (childrens.length > 0) {\n        getChildren(d, depth + 1);\n      } else {\n        leafs.push(d);\n      }\n    }\n  }\n\n  return { list, leafs, roots };\n}\n\nexport function getDataListWithExpanded(list, expandedKeys = [], rowKey) {\n  let arr = [];\n\n  for (let i = 0; i < list.length; i++) {\n    let d = list[i];\n\n    d.__depth = 0;\n\n    arr.push(d);\n\n    if (expandedKeys.indexOf(d[rowKey]) > -1) {\n      if (d.children) {\n        setChildren(d, 0);\n      }\n    }\n  }\n\n  function setChildren(c, depth) {\n    let cArr = c.children;\n    for (let i = 0; i < cArr.length; i++) {\n      let d = cArr[i];\n      d.__depth = depth + 1;\n      arr.push(d);\n\n      if (expandedKeys.indexOf(d[rowKey]) > -1) {\n        if (d.children) {\n          setChildren(d, depth + 1);\n        }\n      }\n    }\n  }\n\n  return arr;\n}\n"]}]}